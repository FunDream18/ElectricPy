<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>electricpy.fault API documentation</title>
<meta name="description" content="`electricpy.fault.py`
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>electricpy.fault</code></h1>
</header>
<section id="section-intro">
<hr>
<h2 id="electricpyfaultpy"><code>electricpy.fault.py</code></h2>
<h2 id="included-functions">Included Functions</h2>
<ul>
<li>Single Line to Ground:
phs1g</li>
<li>Double Line to Ground:
phs2g</li>
<li>Line to Line:
phs2</li>
<li>Three-Phase Fault:
phs3</li>
<li>Single Pole Open:
poleopen1</li>
<li>Double Pole Open:
poleopen2</li>
<li>Simple MVA Calculator:
scMVA</li>
<li>Three-Phase MVA Calculator:
phs3mvasc</li>
<li>Single-Phase MVA Calculator:
phs1mvasc</li>
<li>Faulted Bus Voltage:
busvolt</li>
<li>CT Saturation Function:
ct_saturation</li>
<li>CT C-Class Calculator:
ct_cclass</li>
<li>CT Sat. V at rated Burden:
ct_satratburden</li>
<li>CT Voltage Peak Formula:
ct_vpeak</li>
<li>CT Time to Saturation:
ct_timetosat</li>
<li>Transient Recovery Voltage Calc.:
pktransrecvolt</li>
<li>TRV Reduction Resistor:
trvresistor</li>
<li>TOC Trip Time:
toctriptime</li>
<li>TOC Reset Time:
tocreset</li>
<li>Pickup Setting Assistant:
pickup</li>
<li>Radial TOC Coordination Tool:
tdradial</li>
<li>TAP Setting Calculator:
protectiontap</li>
<li>Transformer Current Correction:
correctedcurrents</li>
<li>Operate/Restraint Current Calc.:
iopirt</li>
<li>Symmetrical/RMS Fault Current Calc:
symrmsfaultcur</li>
<li>TOC Fault Current Ratio:
faultratio</li>
<li>Residual Compensation Factor Calc:
residcomp</li>
<li>Distance Elem. Impedance Calc:
distmeasz</li>
<li>Transformer Mismatch Calculator:
transmismatch</li>
<li>High-Impedance Voltage Pickup:
highzvpickup</li>
<li>High-Impedance Minimum Current PU:
highzmini</li>
<li>Instantaneous Overcurrent PU:
instoc</li>
<li>Generator Loss of Field Settings:
genlossfield</li>
<li>Thermal Time Limit Calculator:
thermaltime</li>
<li>Synchronous Machine Symm. Current:
synmach_Isym</li>
<li>Synchronous Machine Asymm. Current:
synmach_Iasym</li>
<li>Induction Machine Eigenvalue Calc.:
indmacheigenvalues</li>
<li>Induction Machine 3-Phase-SC Calc.:
indmachphs3sc</li>
<li>Induction Machine 3-Phs-Torq. Calc.:
indmachphs3torq</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###################################################################
&#34;&#34;&#34;
---------------------
`electricpy.fault.py`
---------------------

Included Functions
------------------
- Single Line to Ground:                phs1g
- Double Line to Ground:                phs2g
- Line to Line:                         phs2
- Three-Phase Fault:                    phs3
- Single Pole Open:                     poleopen1
- Double Pole Open:                     poleopen2
- Simple MVA Calculator:                scMVA
- Three-Phase MVA Calculator:           phs3mvasc
- Single-Phase MVA Calculator:          phs1mvasc
- Faulted Bus Voltage:                  busvolt
- CT Saturation Function:               ct_saturation
- CT C-Class Calculator:                ct_cclass
- CT Sat. V at rated Burden:            ct_satratburden
- CT Voltage Peak Formula:              ct_vpeak
- CT Time to Saturation:                ct_timetosat
- Transient Recovery Voltage Calc.:     pktransrecvolt
- TRV Reduction Resistor:               trvresistor
- TOC Trip Time:                        toctriptime
- TOC Reset Time:                       tocreset
- Pickup Setting Assistant:             pickup
- Radial TOC Coordination Tool:         tdradial
- TAP Setting Calculator:               protectiontap
- Transformer Current Correction:       correctedcurrents
- Operate/Restraint Current Calc.:      iopirt
- Symmetrical/RMS Fault Current Calc:   symrmsfaultcur
- TOC Fault Current Ratio:              faultratio
- Residual Compensation Factor Calc:    residcomp
- Distance Elem. Impedance Calc:        distmeasz
- Transformer Mismatch Calculator:      transmismatch
- High-Impedance Voltage Pickup:        highzvpickup
- High-Impedance Minimum Current PU:    highzmini
- Instantaneous Overcurrent PU:         instoc
- Generator Loss of Field Settings:     genlossfield
- Thermal Time Limit Calculator:        thermaltime
- Synchronous Machine Symm. Current:    synmach_Isym
- Synchronous Machine Asymm. Current:   synmach_Iasym
- Induction Machine Eigenvalue Calc.:   indmacheigenvalues
- Induction Machine 3-Phase-SC Calc.:   indmachphs3sc
- Induction Machine 3-Phs-Torq. Calc.:  indmachphs3torq
&#34;&#34;&#34;
####################################################################

# Import Necessary Libraries
import numpy as _np
from scipy.optimize import fsolve as _fsolve

# Import Local Dependencies
from .constants import *

def _phaseroll(M012,reference):
    # Compute Dot Product
    M = A012.dot(M012)
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        pass
    elif reference == &#39;B&#39;:
        M = _np.roll(M, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(M, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M)

# Define Single Line to Ground Fault Function
def phs1g(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single-Phase-to-Ground Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single-line-to-ground fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
    
    .. math:: I_2 = I_1
    
    .. math:: I_0 = I_1
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Current
    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
    Ifault = _np.array([ Ifault, Ifault, Ifault ])
    # Prepare Value for return
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    # Return Value
    return(Ifault)
    
# Define Double Line to Ground Fault Current Calculator
def phs2g(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Double-Line-to-Ground Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a double-line-to-ground fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+\\frac{Z_2*(Z_0+3*R_f)}{Z_0+Z_2+3*R_f}}
    
    .. math:: I_2 = -\\frac{V_{th}-Z_1*I_1}{X_2}
    
    .. math:: I_0 = -\\frac{V_{th}-Z_1*I_1}{X_0+3*R_f}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + (X2*(X0+3*Rf))/(X0+X2+3*Rf))
    If2 = -(Vth - X1*If1)/X2
    If0 = -(Vth - X1*If1)/(X0+3*Rf)
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)

# Define Phase-to-Phase Fault Current Calculator
def phs2(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Line-to-Line Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a phase-to-phase fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+Z_2+R_f}
    
    .. math:: I_2 = -I_1
    
    .. math:: I_0 = 0
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If0 = 0
    If1 = Vth / (X1 + X2 + Rf)
    If2 = -If1
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)

# Define Three-Phase Fault Current Calculator
def phs3(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Three-Phase Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a three-phase fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+R_1}
    
    .. math:: I_2 = 0
    
    .. math:: I_0 = 0
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex
                The Fault Current, equal for 0, pos., and neg. seq.
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X1, complex)): X1 *= 1j
    # Calculate Fault Currents
    Ifault = Vth/(X1 + Rf)
    Ifault = _np.array([ 0, Ifault, 0 ])
    # Prepare to Return Value
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)

# Define Single Pole Open Calculator
def poleopen1(Vth,Zseq,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single Pole Open Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single pole open fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+(\\frac{1}{Z_2}+\\frac{1}{Z_0})^-1}
    
    .. math:: I_2 = -I_1 * \\frac{Z_0}{Z_2+Z_0}
    
    .. math:: I_0 = -I_1 * \\frac{Z_2}{Z_2+Z_0}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference, or the
                faulted phase indicator; default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + (1/X2 + 1/X0)**(-1))
    If2 = -If1 * X0/(X2 + X0)
    If0 = -If1 * X2/(X2 + X0)
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)

# Define Double Pole Open Calculator
def poleopen2(Vth,Zseq,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single Pole Open Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single pole open fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+Z_2+Z_0}
    
    .. math:: I_2 = I_1
    
    .. math:: I_0 = I_1
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference, or the
                faulted phase indicator; default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + X2 + X0)
    If2 = If1
    If0 = If1
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)

# Define MVA Short Circuit
def scMVA(Zth=None,Isc=None,Vth=1):
    &#34;&#34;&#34;
    Simple Short-Circuit MVA Calculator
    
    Function defines a method of interpretively
    calculating the short-circuit MVA value
    given two of the three arguments. The formulas
    are all based around the following:
    
    .. math:: MVA_{sc} = V_{th}*I_{sc}
    
    .. math:: V_{th} = I_{sc}*Z_{th}
    
    Parameters
    ----------
    Zth:        float
                The Thevenin-Equivalent-Impedance
    Isc:        float, optional
                Short-Circuit-Current, if left as
                None, will force function to use
                default setting for Vth.
                default=None
    Vth:        float, optional
                The Thevenin-Equivalent-Voltage,
                defaults to a 1-per-unit value.
                default=1
    
    Returns
    -------
    MVA:        float
                Short-Circuit MVA, not described
                as three-phase or otherwise, such
                determination is dependent upon
                inputs.
    &#34;&#34;&#34;
    # Test for too few inputs
    if not any((Zth,Isc)):
        raise ValueError(&#34;Either Zth or Isc must be specified.&#34;)
    # Condition Inputs
    if Zth is not None:
        Zth = abs(Zth)
    if Isc is not None:
        Isc = abs(Isc)
    if Vth != 1:
        Vth = abs(Vth)
    # Calculate MVA from one of the available methods
    if all((Zth,Isc)):
        MVA = Isc**2 * Zth
    elif all((Zth,Vth)):
        MVA = Vth**2 / Zth
    else:
        MVA = Vth * Isc
    # Return Value
    return(MVA)

# Define Explicitly 3-Phase MVAsc Calculator
def phs3mvasc(Vth,Zseq,Rf=0,Sbase=1):
    &#34;&#34;&#34;
    Three-Phase MVA Short-Circuit Calculator
    
    Calculator to evaluate the Short-Circuit MVA of a three-phase fault given the system
    parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
    
    .. math:: MVA_{sc} = \\frac{\\left|V_{th}^2\\right|}{|Z_1|} * Sbase
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    Sbase:      real, optional
                The per-unit base for power. default=1
    
    Returns
    -------
    MVA:        real
                Three-Phase Short-Circuit MVA.
    &#34;&#34;&#34;
    # Calculate Three-Phase MVA
    MVA = abs(Vth)**2 / abs(Zseq[1]) * Sbase
    # Scale VA to MVA if Sbase is not 1
    if Sbase != 1:
        MVA = MVA * 1e-6 # Divide by 1e6 (M)
    # Return
    return(MVA)
    
    
# Define Explicitly 1-Phase MVAsc Calculator
def phs1mvasc(Vth,Zseq,Rf=0,Sbase=1):
    &#34;&#34;&#34;
    Single-Phase MVA Short-Circuit Calculator
    
    Calculator to evaluate the Short-Circuit MVA of a single-phase fault given the system
    parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
    
    .. math:: MVA_{sc} = \\left|I_1^2\\right|*|Z_1| * Sbase
    
    where:
    
    .. math:: I_1 = \\frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    Sbase:      real, optional
                The per-unit base for power. default=1
    
    Returns
    -------
    MVA:        real
                Single-Phase Short-Circuit MVA.
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Current
    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
    # Calculate MVA
    MVA = abs(Ifault)**2 * abs(X1) * Sbase
    # Scale VA to MVA if Sbase is not 1
    if Sbase != 1:
        MVA = MVA * 1e-6 # Divide by 1e6 (M)
    # Return
    return(MVA)

# Define Faulted Bus Voltage Calculator
def busvolt(k,n,Vpf,Z0,Z1,Z2,If,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Faulted Bus Voltage Calculator
    
    This function is designed to calculate the bus voltage(s)
    given a specific set of fault characteristics.
    
    Parameters
    ----------
    k:          float
                Bus index at which to calculate faulted voltage
    n:          float
                Bus index at which fault occurred
    Vpf:        complex
                Voltage Pre-Fault, Singular Number
    Z0:         ndarray
                Zero-Sequence Impedance Matrix
    Z1:         ndarray
                Positive-Sequence Impedance Matrix
    Z2:         ndarray
                Negative-Sequence Impedance Matrix
    If:         complex
                Sequence Fault Current Evaluated at Bus *n*
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Vf:         complex
                The Fault Voltage, set of sequence or phase voltages as
                specified by *sequence*
    &#34;&#34;&#34;
    # Condition Inputs
    k = k-1
    n = n-1
    Z0 = _np.asarray(Z0)
    Z1 = _np.asarray(Z1)
    Z2 = _np.asarray(Z2)
    If = _np.asarray(If)
    # Generate Arrays For Calculation
    Vfmat = _np.array([0, Vpf, 0]).T
    Zmat = _np.array([[Z0[k,n], 0, 0],
                     [0, Z1[k,n], 0],
                     [0, 0, Z2[k,n]]])
    # Perform Calculation
    Vf = Vfmat - Zmat.dot(If)
    if not sequence:
        Vf = _phaseroll( Vf, reference ) # Convert to ABC-Domain
    return(Vf)


# Define CT Saturation Function
def ct_saturation(XoR,Imag,Vrated,Irated,CTR,Rb,Xb,remnance=0,freq=60,ALF=20):
    &#34;&#34;&#34;
    Current Transformer Saturation Calculator
    
    A function to determine the saturation value and a boolean indicator
    showing whether or not CT is -in fact- saturated.
    
    To perform this evaluation, we must satisfy the equation:
    
    .. math::
       20\\geq(1+\\frac{X}{R})*\\frac{|I_{mag}|}{I_{rated}*CTR}
       *\\frac{\\left|R_{burden}+j*\\omega*\\frac{X_{burden}}
       {\\omega}\\right|*100}{V_{rated}*(1-remnanc)}
    
    Parameters
    ----------
    XoR:        float
                The X-over-R ratio of the system.
    Imag:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    Vrated:     float
                The rated voltage (accompanying the C-Class value) of
                the CT.
    Irated:     float
                The rated secondary current for the CT.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Rb:         float
                The total burden resistance in ohms.
    Xb:         float
                The total burden reactance in ohms.
    remnance:   float, optional
                The system flux remnance, default=0.
    freq:       float, optional
                The system frequency in Hz, default=60.
    ALF:        float, optional
                The Saturation Constant which must be satisfied,
                default=20.
    
    Returns
    -------
    result:     float
                The calculated Saturation value.
    saturation: bool
                Boolean indicator to mark presence of saturation.
    &#34;&#34;&#34;
    # Define omega
    w = 2*_np.pi*freq
    # Find Lb
    Lb = Xb/w
    # Re-evaluate Vrated
    Vrated = Vrated*(1-remnance)
    # Calculate each &#34;term&#34; (multiple)
    t1 = (1+XoR)
    t2 = (Imag/(Irated*CTR))
    t3 = abs(Rb+1j*w*Lb)*100/Vrated
    # Evaluate
    result = t1*t2*t3
    # Test for saturation
    saturation = result &gt;= ALF
    # Return Results
    return(result,saturation)


# Define C-Class Calculator
def ct_cclass(XoR,Imag,Irated,CTR,Rb,Xb,remnance=0,freq=60,ALF=20):
    &#34;&#34;&#34;
    Current Transformer (CT) C-Class Function
    
    A function to determine the C-Class rated voltage for a CT.
    The formula shown below is used.
    
    .. math::
       C_{class}=\\frac{(1+\\frac{X}{R})*\\frac{|I_{mag}|}
       {I_{rated}*CTR}*\\frac{\\left|R_{burden}+j*\\omega*
       \\frac{X_{burden}}{\\omega}\\right|*100}{V_{rated}}}
       {1-remnance}
    
    Parameters
    ----------
    XoR:        float
                The X-over-R ratio of the system.
    Imag:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    Irated:     float
                The rated secondary current for the CT.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Rb:         float
                The total burden resistance in ohms.
    Xb:         float
                The total burden reactance in ohms.
    remnance:   float, optional
                The system flux remnance, default=0.
    freq:       float, optional
                The system frequency in Hz, default=60.
    ALF:        float, optional
                The Saturation Constant which must be satisfied,
                default=20.
    
    Returns
    -------
    c_class:    float
                The calculated C-Class rated voltage.
    &#34;&#34;&#34;
    # Define omega
    w = 2*_np.pi*freq
    # Find Lb
    Lb = Xb/w
    # Calculate each &#34;term&#34; (multiple)
    t1 = (1+XoR)
    t2 = (Imag/(Irated*CTR))
    t3 = abs(Rb+1j*w*Lb)*100/ALF
    # Evaluate
    Vr_w_rem = t1*t2*t3
    c_class = Vr_w_rem/(1-remnance)
    # Return Result
    return(c_class)


# Define Saturation Voltage at Rated Burden
def ct_satratburden(Inom,VArat=None,ANSIv=None,ALF=20,):
    &#34;&#34;&#34;
    Current Transformer (CT) Saturation at Rated Burden Calculator
    
    A function to determine the Saturation at rated burden.
    
    .. math:: V_{saturated}=ALF*\\frac{VA_{rated}}{I_{nominal}}
    
    where:
    
    .. math:: VA_{rated}=I_{nominal}*\\frac{ANSI_{voltage}}{20}
    
    Parameters
    ----------
    Inom:       float
                Nominal Current
    VArat:      float, optional, exclusive
                The apparent power (VA) rating of the CT.
    ANSIv:      float, optional, exclusive
                The ANSI voltage requirement to meet.
    ALF:        float, optional
                Accuracy Limit Factor, default=20.
    
    Returns
    -------
    Vsat:       float
                The saturated voltage.
    &#34;&#34;&#34;
    # Validate Inputs
    if VArat == None and ANSIv == None:
        raise ValueError(&#34;VArat or ANSIv must be specified.&#34;)
    elif VArat==None:
        # Calculate VArat from ANSIv
        VArat = Inom*ANSIv/(20)
    # Determine Vsaturation
    Vsat = ALF * VArat/Inom
    return(Vsat)


# Define CT Vpeak Formula
def ct_vpeak(Zb,Ip,CTR):
    &#34;&#34;&#34;
    Current Transformer (CT) Peak Voltage Calculator
    
    Simple formula to calculate the Peak Voltage of a CT.
    
    .. math:: \\sqrt{3.5*|Z_burden|*I_{peak}*CTR}
    
    Parameters
    ----------
    Zb:         float
                The burden impedance magnitude (in ohms).
    Ip:         float
                The peak current for the CT.
    CTR:        float
                The CTR turns ratio of the CT.
    
    Returns
    -------
    Vpeak:      float
                The peak voltage.
    &#34;&#34;&#34;
    return(_np.sqrt(3.5*abs(Zb)*Ip*CTR))


# Define Saturation Time Calculator
def ct_timetosat(Vknee,XoR,Rb,CTR,Imax,ts=None,npts=100,freq=60,plot=False):
    &#34;&#34;&#34;
    Current Transformer (CT) Time to Saturation Function
    
    Function to determine the &#34;time to saturate&#34; for an underrated C-Class
    CT using three standard curves described by Juergen Holbach.
    
    Parameters
    ----------
    Vknee:      float
                The knee-voltage for the CT.
    XoR:        float
                The X-over-R ratio of the system.
    Rb:         float
                The total burden resistance in ohms.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Imax:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    ts:         numpy.ndarray or float, optional
                The time-array or particular (floatint point) time at which
                to calculate the values. default=_np.linspace(0,0.1,freq*npts)
    npts:       float, optional
                The number of points (per cycle) to calculate if ts is not
                specified, default=100.
    freq:       float, optional
                The system frequency in Hz, default=60.
    plot:       bool, optional
                Control argument to enable plotting of calculated curves,
                default=False.
    &#34;&#34;&#34;
    # Calculate omega
    w = 2*_np.pi*freq
    # Calculate Tp
    Tp = XoR/w
    # If ts isn&#39;t specified, generate it
    if ts==None:
        ts = _np.linspace(0,0.1,freq*npts)
    # Calculate inner term
    term = -XoR*(_np.exp(-ts/Tp)-1)
    # Calculate Vsaturation terms
    Vsat1 = Imax*Rb*(term+1)
    Vsat2 = Imax*Rb*(term-_np.sin(w*ts))
    Vsat3 = Imax*Rb*(1-_np.cos(w*ts))
    # If plotting requested
    if plot and isinstance(ts,_np.ndarray):
        plt.plot(ts,Vsat1,label=&#34;Vsat1&#34;)
        plt.plot(ts,Vsat2,label=&#34;Vsat2&#34;)
        plt.plot(ts,Vsat3,label=&#34;Vsat3&#34;)
        plt.axhline(Vknee,label=&#34;V-knee&#34;,linestyle=&#39;--&#39;)
        plt.title(&#34;Saturation Curves&#34;)
        plt.xlabel(&#34;Time (ts)&#34;)
        plt.legend()
        plt.show()
    elif plot:
        print(&#34;Unable to plot a single point, *ts* must be a numpy-array.&#34;)
    # Determine the crossover points for each saturation curve
    Vsat1c = Vsat2c = Vsat3c = 0
    if isinstance(ts,_np.ndarray):
        for i in range(len(ts)):
            if Vsat1[i]&gt;Vknee and Vsat1c==0:
                Vsat1c = ts[i-1]
            if Vsat2[i]&gt;Vknee and Vsat2c==0:
                Vsat2c = ts[i-1]
            if Vsat3[i]&gt;Vknee and Vsat3c==0:
                Vsat3c = ts[i-1]
        results = (Vsat1c,Vsat2c,Vsat3c)
    else:
        results = (Vsat1,Vsat2,Vsat3)
    return(results)

# Define Function to Calculate TRV
def pktransrecvolt(C,L,R=0,VLL=None,VLN=None,freq=60):
    &#34;&#34;&#34;
    Peak Transient Recovery Function
    
    Peak Transient Recovery Voltage calculation
    function, evaluates the peak transient
    recovery voltage (restriking voltage) and
    the Rate-of-Rise-Recovery Voltage.
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    R:          float, optional
                The resistance of the system used for
                calculation, default=0.
    VLL:        float, exclusive
                Line-to-Line voltage, exclusive
                optional argument.
    VLN:        float, exclusive
                Line-to-Neutral voltage, exclusive
                optional argument.
    freq:       float, optional
                System frequency in Hz.
    
    Returns
    -------
    Vcpk:       float
                Peak Transient Recovery Voltage in volts.
    RRRV:       float
                The RRRV (Rate-of-Rise-Recovery Voltage)
                calculated given the parameters in volts
                per second.
    &#34;&#34;&#34;
    # Evaluate alpha, omega-n, and fn
    alpha = R/(2*L)
    wn = 1/_np.sqrt(L*C) - alpha
    fn = wn/(2*_np.pi)
    # Evaluate Vm
    if VLL!=None:
        Vm = _np.sqrt(2/3)*VLL
    elif VLN!=None:
        Vm = _np.sqrt(2)*VLN
    else:
        raise ValueError(&#34;One voltage must be specified.&#34;)
    # Evaluate Vcpk (worst case)
    Vcpk = wn**2/(wn**2-2*_np.pi*freq)*Vm*2
    # Evaluate RRRV
    RRRV = 2*Vm*fn/0.5
    return(Vcpk,RRRV)

# Define TRV Reduction Resistor Function
def trvresistor(C,L,reduction,Rd0=500,wd0=260e3,tpk0=10e-6):
    &#34;&#34;&#34;
    Transient Recovery Voltage (TRV) Reduction Resistor Function
    
    Function to find the resistor value that
    will reduce the TRV by a specified
    percentage.
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    reduction:  float
                The percentage that the TRV
                should be reduced by.
    Rd0:        float, optional
                Damping Resistor Evaluation Starting Point
                default=500
    wd0:        float, optional
                Omega-d evaluation starting point, default=260*k
    tpk0:       float, optional
                Time of peak voltage evaluation starting point,
                default=10*u
    
    Returns
    -------
    Rd:         float
                Damping resistor value, in ohms.
    wd:         float
                Omega-d
    tpk:        float
                Time of peak voltage.
    &#34;&#34;&#34;
    # Evaluate omega-n
    wn = 1/_np.sqrt(L*C)
    # Generate Constant Factor
    fctr = (1-reduction)*2 - 1
    # Define Function Set
    def equations(data):
        Rd, wd, tpk = data
        X = _np.sqrt(wn**2-(1/(2*Rd*C))**2) - wd
        Y = _np.exp(-tpk/(2*Rd*C))-fctr
        Z = wd*tpk - _np.pi
        return(X,Y,Z)
    Rd, wd, tpk = _fsolve(equations, (Rd0,wd0,tpk0))
    return(Rd, wd, tpk)

# Define Time-Overcurrent Trip Time Function
def toctriptime(I,Ipickup,TD,curve=&#34;U1&#34;,CTR=1):
    &#34;&#34;&#34;
    Time OverCurrent Trip Time Function
    
    Time-OverCurrent Trip Time Calculator, evaluates the time
    to trip for a specific TOC (51) element given the curve
    type, current characteristics and time-dial setting.
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    TD:         float
                Time Dial Setting
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    tt:         float
                Time-to-Trip for characterized element.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    const = {   &#34;U1&#34; : {&#34;A&#34;: 0.0104, &#34;B&#34;: 0.2256, &#34;P&#34;: 0.02},
                &#34;U2&#34; : {&#34;A&#34;: 5.95, &#34;B&#34;: 0.180, &#34;P&#34;: 2.00},
                &#34;U3&#34; : {&#34;A&#34;: 3.88, &#34;B&#34;: 0.0963, &#34;P&#34;: 2.00},
                &#34;U4&#34; : {&#34;A&#34;: 5.67, &#34;B&#34;: 0.352, &#34;P&#34;: 2.00},
                &#34;U5&#34; : {&#34;A&#34;: 0.00342, &#34;B&#34;: 0.00262, &#34;P&#34;: 0.02},
                &#34;C1&#34; : {&#34;A&#34;: 0.14, &#34;B&#34;:0, &#34;P&#34;: 0.02},
                &#34;C2&#34; : {&#34;A&#34;: 13.5, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C3&#34; : {&#34;A&#34;: 80.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C4&#34; : {&#34;A&#34;: 120.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C5&#34; : {&#34;A&#34;: 0.05, &#34;B&#34;:0, &#34;P&#34;: 0.04}}
    # Load Constants
    A = const[curve][&#34;A&#34;]
    B = const[curve][&#34;B&#34;]
    P = const[curve][&#34;P&#34;]
    # Evaluate M
    M = I / (CTR * Ipickup)
    # Evaluate Trip Time
    tt = TD * (A/(M**P-1)+B)
    return(tt)

# Define Time Overcurrent Reset Time Function
def tocreset(I,Ipickup,TD,curve=&#34;U1&#34;,CTR=1):
    &#34;&#34;&#34;
    Time OverCurrent Reset Time Function
    
    Function to calculate the time to reset for a TOC
    (Time-OverCurrent, 51) element.
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    TD:         float
                Time Dial Setting
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    tr:         float
                Time-to-Reset for characterized element.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    C = {   &#34;U1&#34; : 1.08,&#34;U2&#34; : 5.95,&#34;U3&#34; : 3.88,
            &#34;U4&#34; : 5.67,&#34;U5&#34; : 0.323,&#34;C1&#34; : 13.5,
            &#34;C2&#34; : 47.3,&#34;C3&#34; : 80.0,&#34;C4&#34; : 120.0,
            &#34;C5&#34; : 4.85}
    # Evaluate M
    M = I / (CTR * Ipickup)
    # Evaluate Reset Time
    tr = TD * (C[curve]/(1-M**2))
    return(tr)

# Define Pickup Current Calculation
def pickup(Iloadmax,Ifaultmin,scale=0,printout=False,units=&#34;A&#34;):
    &#34;&#34;&#34;
    Current Pickup Selection Assistant
    
    Used to assist in evaluating an optimal phase-over-current pickup
    setting. Uses maximum load and minimum fault current to provide
    user assistance.
    
    Parameters
    ----------
    Iloadmax:   float
                The maximum load current in amps.
    Ifaultmin:  float
                The minimum fault current in amps.
    scale:      int, optional
                Control scaling to set number of significant figures.
                default=0
    printout:   boolean, optional
                Control argument to enable printing of intermediate
                stages, default=False.
    units:      string, optional
                String to be appended to any printed output denoting
                the units of which are being printed, default=&#34;A&#34;
    
    Returns
    -------
    setpoint:   float
                The evaluated setpoint at which the function suggests
                the phase-over-current pickup setting be placed.
    &#34;&#34;&#34;
    IL2 = 2*Iloadmax
    IF2 = Ifaultmin/2
    exponent = len(str(IL2).split(&#39;.&#39;)[0])
    setpoint = _np.ceil(IL2*10**(-exponent+1+scale))*10**(exponent-1-scale)
    if printout:
        print(&#34;Range Min:&#34;,IL2,units,&#34;\t\tRange Max:&#34;,IF2,units)
    if IF2 &lt; setpoint:
        setpoint = IL2
        if IL2 &gt; IF2:
            raise ValueError(&#34;Invalid Parameters.&#34;)
    if printout:
        print(&#34;Current Pickup:&#34;,setpoint,units)
    return(setpoint)

# Define Time-Dial Coordination Function
def tdradial(I,CTI,Ipu_up,Ipu_dn=0,TDdn=0,curve=&#34;U1&#34;,scale=2,freq=60,
                  CTR_up=1,CTR_dn=1,tfixed=None):
    &#34;&#34;&#34;
    Radial Time Dial Coordination Function
    
    Function to evaluate the Time-Dial (TD) setting in radial schemes
    where the Coordinating Time Interval (CTI) and the up/downstream
    pickup settings are known along with the TD setting for the
    downstream protection.
    
    Parameters
    ----------
    I:          float
                Measured fault current in Amps, typically set using the
                maximum fault current available.
    CTI:        float
                Coordinating Time Interval in cycles.
    Ipu_up:     float
                Pickup setting for upstream protection,
                specified in amps
    Ipu_dn:     float, optional
                Pickup setting for downstream protection,
                specified in amps, default=0
    TDdn:       float, optional
                Time-Dial setting for downstream protection,
                specified in seconds, default=0
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    scale:      int, optional
                Scaling value used to evaluate a practical TD
                setting, default=2
    freq:       float, optional
                System operating frequency, default=60
    CTR_up:     float, optional
                Current Transformer Ratio for upstream relay.
                default=1
    CTR_dn:     float, optional
                Current Transformer Ratio for downstream relay.
                default=1
    tfixed:     float, optional
                Used to specify a fixed time delay for coordinated
                protection elements, primarily used for coordinating
                TOC elements (51) with OC elements (50) with a fixed
                tripping time. Overrides downstream TOC arguments
                including *Ipu_dn* and *TDdn*.
    
    Returns
    -------
    TD:         float
                Calculated Time-Dial setting according to radial
                scheme logical analysis.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    const = {   &#34;U1&#34; : {&#34;A&#34;: 0.0104, &#34;B&#34;: 0.2256, &#34;P&#34;: 0.02},
                &#34;U2&#34; : {&#34;A&#34;: 5.95, &#34;B&#34;: 0.180, &#34;P&#34;: 2.00},
                &#34;U3&#34; : {&#34;A&#34;: 3.88, &#34;B&#34;: 0.0963, &#34;P&#34;: 2.00},
                &#34;U4&#34; : {&#34;A&#34;: 5.67, &#34;B&#34;: 0.352, &#34;P&#34;: 2.00},
                &#34;U5&#34; : {&#34;A&#34;: 0.00342, &#34;B&#34;: 0.00262, &#34;P&#34;: 0.02},
                &#34;C1&#34; : {&#34;A&#34;: 0.14, &#34;B&#34;:0, &#34;P&#34;: 0.02},
                &#34;C2&#34; : {&#34;A&#34;: 13.5, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C3&#34; : {&#34;A&#34;: 80.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C4&#34; : {&#34;A&#34;: 120.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C5&#34; : {&#34;A&#34;: 0.05, &#34;B&#34;:0, &#34;P&#34;: 0.04}}
    # Load Constants
    A = const[curve][&#34;A&#34;]
    B = const[curve][&#34;B&#34;]
    P = const[curve][&#34;P&#34;]
    if tfixed == None:
        # Evaluate in seconds from cycles
        CTI = CTI/freq
        # Evaluate M
        M = I / (CTR_dn * Ipu_dn)
        # Evaluate Trip Time
        tpu_desired = TDdn * (A/(M**P-1)+B) + CTI
    else:
        tpu_desired = tfixed + CTI
    # Re-Evaluate M
    M = I / (CTR_up * Ipu_up)
    # Calculate TD setting
    TD = tpu_desired / (A/(M**2-1)+B)
    # Scale and Round
    TD = _np.floor(TD*10**scale)/10**scale
    return(TD)

# Define TAP Calculator
def protectiontap(S,CTR=1,VLN=None,VLL=None):
    &#34;&#34;&#34;
    Protection TAP Setting Calculator
    
    Evaluates the required TAP setting based on the rated power of
    a transformer (the object being protected) and the voltage
    (either primary or secondary) in conjunction with the CTR
    (current transformer ratio) for the side in question (primary/
    secondary).
    
    Parameters
    ----------
    CTR:        float
                The Current Transformer Ratio.
    S:          float
                Rated apparent power magnitude (VA/VAR/W).
    VLN:        float, exclusive
                Line-to-Neutral voltage in volts.
    VLL:        float, exclusive
                Line-to-Line voltage in volts.
    
    Returns
    -------
    TAP:        float
                The TAP setting required to meet the specifications.
    &#34;&#34;&#34;
    # Condition Voltage(s)
    if VLL != None:
        V = abs(_np.sqrt(3)*VLL)
    elif VLN != None:
        V = abs(3 * VLN)
    else:
        raise ValueError(&#34;One or more voltages must be provided.&#34;)
    # Calculate TAP
    TAP = abs(S) / (V*CTR)
    return(TAP)



# Define Current Correction Calculator
def correctedcurrents(Ipri,TAP,correction=&#34;Y&#34;,CTR=1):
    &#34;&#34;&#34;
    Transformer Current Correction Function
    
    Function to evaluate the currents as corrected for microprocessor-
    based relay protection schemes.
    
    Parameters
    ----------
    Ipri:       list of complex
                Three-phase set (IA, IB, IC) of primary currents.
    TAP:        float
                Relay&#39;s TAP setting.
    correction: string, optional
                String defining correction factor, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    CTR:        float
                Current Transformer Ratio, default=1
    
    Returns
    -------
    Isec_corr:  list of complex
                The corrected currents to perform operate/restraint
                calculations with.
    &#34;&#34;&#34;
    # Define Matrix Lookup
    MAT = {   &#34;Y&#34;  : XFMY0,
              &#34;D+&#34; : XFMD1,
              &#34;D-&#34; : XFMD11,
              &#34;Z&#34;  : XFM12}
    # Condition Inputs
    Ipri = _np.asarray(Ipri)
    if isinstance(correction,list):
        mult = MAT[correction[0]]
        for i in correction[1:]:
            mult = mult.dot(MAT[i])
    elif isinstance(correction,str):
        mult = MAT[correction]
    elif isinstance(correction,_np.ndarray):
        mult = correction
    else:
        raise ValueError(&#34;Correction must be string or list of strings.&#34;)
    # Evaluate Corrected Current
    Isec_corr = 1/TAP * mult.dot(Ipri/CTR)
    return(Isec_corr)



# Define Iop/Irt Calculator
def iopirt(IpriHV,IpriLV,TAPHV,TAPLV,corrHV=&#34;Y&#34;,corrLV=&#34;Y&#34;,CTRHV=1,CTRLV=1):
    &#34;&#34;&#34;
    Operate/Restraint Current Calculator
    
    Calculates the operating current (Iop) and the restraint
    current (Irt) as well as the slope.
    
    Parameters
    ----------
    IpriHV:     list of complex
                Three-phase set (IA, IB, IC) of primary currents
                on the high-voltage side of power transformer.
    IpriLV      list of complex
                Three-phase set (IA, IB, IC) of primary currents
                on the low-voltage side of power transformer.
    TAPHV       float
                Relay&#39;s TAP setting for high-voltage side of
                power transformer.
    TAPLV       float
                Relay&#39;s TAP setting for low-voltage side of
                power transformer.
    corrHV      string, optional
                String defining correction factor on high-voltage
                side of power transformer, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    corrLV      string, optional
                String defining correction factor on low-voltage
                side of power transformer, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    CTRHV       float
                Current Transformer Ratio for high-voltage side
                of power transformer, default=1
    CTRLV       float
                Current Transformer Ratio for low-voltage side
                of power transformer, default=1
    
    Returns
    -------
    Iop:        list of float
                The operating currents for phases A, B, and C.
    Irt:        list of float
                The restraint currents for phases A, B, and C.
    slope:      list of float
                The calculated slopes for phases A, B, and C.
    &#34;&#34;&#34;
    # Calculate Corrected Currents
    IcorHV = correctedcurrents(IpriHV,TAPHV,corrHV,CTRHV)
    IcorLV = correctedcurrents(IpriLV,TAPLV,corrLV,CTRLV)
    # Calculate Operate/Restraint Currents
    Iop = _np.absolute( IcorHV + IcorLV )
    Irt = _np.absolute(IcorHV) + _np.absolute(IcorLV)
    # Calculate Slopes
    slope = Iop/Irt
    return(Iop,Irt,slope)

# Define Symmetrical/RMS Current Calculation
def symrmsfaultcur(V,R,X,t=1/60,freq=60):
    &#34;&#34;&#34;
    Symmetrical/RMS Current Calculator
    
    Function to evaluate the time-constant tau,
    the symmetrical fault current, and the RMS
    current for a faulted circuit.
    
    Parameters
    ----------
    V:          float
                Voltage magnitude at fault point,
                not described as line-to-line or
                line-to-neutral.
    R:          float
                The fault resistance in ohms.
    X:          float
                The fault impedance in ohms.
    t:          float, optional
                The time in seconds.
    freq:       float, optional
                The system frequency in Hz.
    
    Returns
    -------
    tau:        float
                The time-constant tau in seconds.
    Isym:       float
                Symmetrical fault current in amps.
    Irms:       float
                RMS fault current in amps.
    &#34;&#34;&#34;
    # Calculate Z and tau
    Z = _np.sqrt(R**2+X**2)
    tau = X/(2*_np.pi*freq*R)
    # Calculate Symmetrical Fault Current
    Isym = (V/_np.sqrt(3))/Z
    # Calculate RMS Fault Current
    Irms = _np.sqrt(1+2*_np.exp(-2*t/tau))*Isym
    return(tau,Isym,Irms)

# Define Relay M Formula
def faultratio(I,Ipickup,CTR=1):
    &#34;&#34;&#34;
    Fault Multiple of Pickup (Ratio) Calculator
    
    Evaluates the CTR-scaled pickup measured to
    pickup current ratio.
    
    M = meas / pickup
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    CTR:        float, optional
                Current Transformer Ratio for relay,
                default=1
    
    Returns
    -------
    M:          float
                The measured-to-pickup ratio
    &#34;&#34;&#34;
    M = I/(CTR * Ipickup)
    return(M)

# Define Residual Compensation Factor Function
def residcomp(z1,z0,linelength=1):
    &#34;&#34;&#34;
    Residual Compensation Factor Function
    
    Evaluates the residual compensation factor based on
    the line&#39;s positive and zero sequence impedance
    characteristics.
    
    Parameters
    ----------
    z1:         complex
                The positive-sequence impedance
                characteristic of the line, specified in 
                ohms-per-unit where the total line length
                (of same unit) is specified in
                *linelength* argument.
    z0:         complex
                The zero-sequence impedance characteristic
                of the line, specified in ohms-per-unit
                where the total line length (of same unit)
                is specified in *linelength* argument.
    linelength: float, optional
                The length (in same base unit as impedance
                characteristics) of the line. default=1
    
    Returns
    -------
    k0:         complex
                The residual compensation factor.
    &#34;&#34;&#34;
    # Evaluate Z1L and Z0L
    Z1L = z1*linelength
    Z0L = z0*linelength
    # Calculate Residual Compensation Factor (k0)
    k0 = (Z0L - Z1L)/(3*Z1L)
    return(k0)

# Define Relay Measured Impedance Functon for Distance Elements
def distmeasz(VLNmeas,If,Ip,Ipp,CTR=1,VTR=1,k0=None,z1=None,z0=None,linelength=1):
    &#34;&#34;&#34;
    Distance Element Measured Impedance Function
    
    Function to evaluate the Relay-Measured-Impedance as calculated from
    the measured voltage, current, and line parameters.
    
    Parameters
    ----------
    VLNmeas:    complex
                Measured Line-to-Neutral voltage for the
                faulted phase in primary volts.
    If:         complex
                Faulted phase current measured in primary
                amps.
    Ip:         complex
                Secondary phase current measured in primary
                amps.
    Ipp:        complex
                Terchiary phase current measured in primary
                amps.
    CTR:        float, optional
                Current transformer ratio, default=1
    VTR:        float, optional
                Voltage transformer ratio, default=1
    k0:         complex, optional
                Residual Compensation Factor
    z1:         complex, optional
                The positive-sequence impedance
                characteristic of the line, specified in 
                ohms-per-unit where the total line length
                (of same unit) is specified in
                *linelength* argument.
    z0:         complex, optional
                The zero-sequence impedance characteristic
                of the line, specified in ohms-per-unit
                where the total line length (of same unit)
                is specified in *linelength* argument.
    linelength: float, optional
                The length (in same base unit as impedance
                characteristics) of the line. default=1
    
    Returns
    -------
    Zmeas:      complex
                The &#34;measured&#34; impedance as calculated by the relay.
    &#34;&#34;&#34;
    # Validate Residual Compensation Inputs
    if k0 == z1 == z0 == None:
        raise ValueError(&#34;Residual compensation arguments must be set.&#34;)
    if k0 == None and (z1==None or z0==None):
        raise ValueError(&#34;Both *z1* and *z0* must be specified.&#34;)
    # Calculate Residual Compensation if Necessary
    if k0 == None:
        k0 = residcomp(z1,z0,linelength)
    # Convert Primary Units to Secondary
    V = VLNmeas/VTR
    Ir = (If + Ip + Ipp)/CTR
    I = If/CTR
    # Calculate Measured Impedance
    Zmeas = V / (I+k0*Ir)
    return(Zmeas)

# Define Transformer Tap Mismatch Function
def transmismatch(I1,I2,tap1,tap2):
    &#34;&#34;&#34;
    Transformer TAP Mismatch Function
    
    Function to evaluate the transformer ratio mismatch
    for protection.
    
    Parameters
    ----------
    I1:         complex
                Current (in amps) on transformer primary side.
    I2:         complex
                Current (in amps) on transformer secondary.
    tap1:       float
                Relay TAP setting on the primary side.
    tap2:       float
                Relay TAP setting on the secondary side.
    
    Returns
    -------
    mismatch:   float
                Transformer CT mismatch value associated with
                relay.
    &#34;&#34;&#34;
    # Evaluate MR
    MR = min( abs(I1/I2), abs(tap1/tap2) )
    # Calculate Mismatch
    mismatch = (abs(I1/I2) - abs(tap1/tap2))*100/MR
    return(mismatch)

# Define High-Impedance Bus Protection Pickup Function
def highzvpickup(I,RL,Rct,CTR=1,threephase=False,Ks=1.5,
                 Vstd=400,Kd=0.5):
    &#34;&#34;&#34;
    High Impedance Pickup Setting Function
    
    Evaluates the voltage pickup setting for a high
    impedance bus protection system.
    
    Parameters
    ----------
    I:          float
                Fault current on primary side (in amps)
    RL:         float
                One-way line resistance in ohms
    Rct:        float
                Current Transformer Resistance in ohms
    CTR:        float, optional
                Current Transformer Ratio, default=1
    threephase: bool, optional
                Control argument to set the function to
                evaluate the result for a three-phase 
                fault or unbalanced fault. default=False
    Ks:         float, optional
                Security Factor for secure voltage pickup
                setting, default=1.5
    Vstd:       float, optional
                C-Class Voltage rating (i.e. C-400),
                default=400
    Kd:         float, optional
                The dependability factor for dependable
                voltage pickup setting, default=0.5
    
    Returns
    -------
    Vsens:      float
                The calculated sensetive voltage-pickup.
    Vdep:       float
                The calculated dependable voltage-pickup.
    &#34;&#34;&#34;
    # Condition Based on threephase Argument
    n = 2
    if threephase: n = 1
    # Evaluate Secure Voltage Pickup
    Vsens = Ks*(n*RL+Rct)*I/CTR
    # Evaluate Dependible Voltage Pickup
    Vdep = Kd*Vstd
    return(Vsens,Vdep)

# Define Minimum Current Pickup for High-Impedance Bus Protection
def highzmini(N,Ie,Irly=None,Vset=None,Rrly=2000,Imov=0,CTR=1):
    &#34;&#34;&#34;
    Minimum Current for High Impedance Protection Calculator
    
    Evaluates the minimum pickup current required to cause
    high-impedance bus protection element pickup.
    
    Parameters
    ----------
    N:          int
                Number of Current Transformers included in scheme
    Ie:         float
                The excitation current at the voltage setting
    Irly:       float, optional
                The relay current at voltage setting
    Vset:       float, optional
                The relay&#39;s voltage pickup setting in volts.
    Rrly:       float, optional
                The relay&#39;s internal resistance in ohms, default=2000
    Imov:       float, optional
                The overvoltage protection current at the
                voltage setting. default=0.0
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    Imin:       float
                Minimum current required to cause high-impedance
                bus protection element pickup.
    &#34;&#34;&#34;
    # Validate Inputs
    if Irly == Vset == None:
        raise ValueError(&#34;Relay Current Required.&#34;)
    # Condition Inputs
    Ie = abs(Ie)
    Imov = abs(Imov)
    if Irly == None:
        Vset = abs(Vset)
        Irly = Vset / Rrly
    else:
        Irly = abs(Irly)
    # Evaluate Minimum Current Pickup
    Imin = (N*Ie+Irly+Imov)*CTR
    return(Imin)

# Define Instantaneous Overcurrent Pickup Formula
def instoc(Imin,CTR=1,Ki=0.5):
    &#34;&#34;&#34;
    Instantaneous OverCurrent Pickup Calculator
    
    Using a sensetivity factor and the CTR, evaluates
    the secondary-level pickup setting for an
    instantaneous overcurrent element.
    
    Parameters
    ----------
    Imin:       float
                The minimum fault current in primary amps.
    CTR:        float, optional
                Current Transformer Ratio, default=1
    Ki:         Sensetivity factor, default=0.5
    
    Returns
    -------
    Ipu:        float
                The pickup setting for the instantaneous
                overcurrent element as referred to the
                secondary side.
    &#34;&#34;&#34;
    # Evaluate Overcurrent Pickup Setting
    Ipu = Ki * abs(Imin)/CTR
    return(Ipu)

# Define Generator Loss of Field Element Function
def genlossfield(Xd,Xpd,Zbase=1,CTR=1,VTR=1):
    &#34;&#34;&#34;
    Generator Loss of Field Function
    
    Generates the Loss-of-Field Element settings
    for a generator using the Xd value and
    per-unit base information.
    
    Parameters
    ----------
    Xd:         float
                The Transient Reactance (Xd) term. May be
                specified in ohms or Per-Unit ohms if
                *Zbase* is set.
    Xpd:        float
                The Sub-Transient Reactance (X&#39;d) term. May
                be specified in ohms or Per-Unit ohms if
                *Zbase* is set.
    Zbase:      float, optional
                Base impedance, used to convert per-unit
                Xd and Xpd to secondary values. default=1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    VTR:        float, optional
                Voltage Transformer Ratio, default=1
    
    Returns
    -------
    ZoneOff:    float
                Zone Offset in ohms.
    Z1dia:      float
                Zone 1 diameter in ohms.
    Z2dia:      float
                Zone 2 diameter in ohms.
    &#34;&#34;&#34;
    # Condition Inputs
    Xd = abs(Xd)
    Xpd = abs(Xpd)
    Zbase = abs(Zbase)
    # Evaluate Xd_sec and Xpd_sec
    Xd_sec = Xd*Zbase*(CTR/VTR)
    Xpd_sec = Xd*Zbase*(CTR/VTR)
    # Determine Zone Offset
    ZoneOff = Xpd_sec/2
    # Evaluate Z1 Diameter and Z2 Diameter
    Z1dia = Zbase*CTR/VTR
    Z2dia = Xd_sec
    # Return
    return(ZoneOff,Z1dia,Z2dia)

# Define Thermal Time Limit Calculator
def thermaltime(In,Ibase,tbase):
    &#34;&#34;&#34;
    Simple Thermal Time Limit Calculator
    
    Computes the maximum allowable time for a specified
    current `In` given parameters for a maximum current
    and time at some other level, (`Ibase`, `tbase`).
    
    Uses the following formula:
    
    .. math:: t_n=\\frac{I_{base}^2*t_{base}}{I_n^2}
    
    Parameters
    ----------
    In:         float
                Current at which to calculate max time.
    Ibase:      float
                Base current, at which maximum time
                `tbase` is allowable.
    tbase:      float
                Base time for which a maximum allowable
                current `Ibase` is specified. Unitless.
    
    Returns
    -------
    tn:         float
                Time allowable for specified current,
                `In`.
    &#34;&#34;&#34;
    # Perform Calculation
    tn = (Ibase**2*tbase)/(In**2)
    return(tn)
    

# Define Synch. Machine Fault Current Calculator
def synmach_Isym(t,Eq,Xd,Xdp,Xdpp,Tdp,Tdpp):
    &#34;&#34;&#34;
    Synch. Machine Symmetrical Fault Current Calc.
    
    Determines the Symmetrical Fault Current of a synchronous
    machine given the machine parameters, the internal voltage,
    and the time for which to calculate.
    
    .. math:: I_a(t)=\\sqrt{2}\\left|E_q\\right|\\left[
       \\frac{1}{X_d}+\\left(\\frac{1}{X&#39;_d}-\\frac{1}{X_d}
       \\right)\\cdot e^{\\frac{-t}{T&#39;_d}}+\\left(\\frac{1}
       {X&#34;_d}-\\frac{1}{X&#39;_d}\\right)\\cdot e^{\\frac{-t}{T&#34;_d}}
       \\right]
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    Xd:         float
                The Xd (d-axis) reactance in per-unit-ohms
    Xdp:        float
                The X&#34;d (d-axis transient) reactance in
                per-unit-ohms
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Tdp:        float
                The T&#39;d (d-axis transient) time constant of the
                machine in seconds
    Tdpp:       float
                The T&#34;d (d-axis subtransient) time constant of
                the machine in seconds
    
    Returns
    -------
    Ia:         float
                Peak symmetrical fault current in per-unit-amps
    &#34;&#34;&#34;
    # Calculate Time-Constant Term
    t_c = 1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)+(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp)
    # Calculate Fault Current
    Ia = _np.sqrt(2)*abs(Eq)*t_c
    return(Ia)

# Define Synch. Machine Asymmetrical Current Calculator
def synmach_Iasym(t,Eq,Xdpp,Xqpp,Ta):
    &#34;&#34;&#34;
    Synch. Machine Asymmetrical Fault Current Calc.
    
    Determines the asymmetrical fault current of a synchronous
    machine given the machine parameters, the internal voltage,
    and the time for which to calculate.
    
    .. math:: I_{asym}=\\sqrt{2}\\left|E_q\\right|\\frac{1}{2}
       \\left(\\frac{1}{X&#34;_d}+\\frac{1}{X&#34;_q}\\right)e^{\\frac{-t}
       {T_a}}
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Xqpp:       float
                The X&#34;q (q-axis subtransient) reactance in
                per-unit-ohms
    Ta:         float
                Armature short-circuit (DC) time constant in seconds
    
    Returns
    -------
    Iasym:      float
                Peak asymmetrical fault current in per-unit-amps
    &#34;&#34;&#34;
    # Calculate Time Constant Term
    t_c = 1/Xdpp + 1/Xqpp
    # Calculate Asymmetrical Current
    Iasym = _np.sqrt(2)*abs(Eq)*1/2*t_c*_np.exp(-t/Ta)
    return(Iasym)

# Define Induction Machine Eigenvalue Calculator
def indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
    &#34;&#34;&#34;
    Induction Machine Eigenvalue Calculator
    
    Calculates the pertinent eigenvalues for an unloaded
    induction machine given a specific set of machine
    parameters.
    
    Parameters
    ----------
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    
    Returns
    -------
    lam1:       complex
                The First Eigenvalue
    lam2:       complex
                The Second Eigenvalue
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_e_base = 2*_np.pi*freq
    omega_rf = wrf
    torque_s = Ls/(omega_e_base*Rs)
    torque_r = Lr/(omega_e_base*Rr)
    alpha = torque_r / torque_s
    phi = 1 - Lm**2/(Ls*Lr)
    omega_r = omega_e_base
    # Calculate k1
    k1 = -1/(2*phi*torque_r)*(1+alpha)
    k1 += 1j*(omega_r/2-omega_rf)
    # Calculate k2
    k2 = 1/(2*phi*torque_r)
    k2 *= _np.sqrt((1+alpha)**2-4*phi*alpha-(omega_r*phi*torque_r)**2
                 +2j*(alpha-1)*omega_r*phi*torque_r)
    # Evaluate Eigenvalues and Return
    lam1 = k1+k2
    lam2 = k1-k2
    return(lam1,lam2)

# Define IM 3-Phase SC Current Calculator
def indmachphs3sc(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60,real=True):
    &#34;&#34;&#34;
    Induction Machine 3-Phase SC Calculator
    
    Determines the short-circuit current at
    a specified time for a three-phase fault
    on an unloaded induction machine.
    
    Parameters
    ----------
    t:          array_like
                The time at which to find the
                current, may be int, float, or
                numpy array.
    Is0:        complex
                The initial (t=0) current on
                the stator.
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    real:       bool, optional
                Control argument to force returned value
                to be real part only. default=True
    
    Returns
    -------
    ias:        array_like
                Fault Current
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_r = 2*_np.pi*freq
    torque_s = Ls/(omega_r*Rs)
    phi = 1 - Lm**2/(Ls*Lr)
    # Calculate Eigenvalues
    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
    # Calculate pIs0
    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
    # Calculate Constants
    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
    # Calculate ias and Return
    ias = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
    if real:
        ias = _np.real(ias)
    return(ias)

# Define IM Torque Calculation
def indmachphs3torq(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
    &#34;&#34;&#34;
    Parameters
    ----------
    t:          array_like
                The time at which to find the
                current, may be int, float, or
                numpy array.
    Is0:        complex
                The initial (t=0) current on
                the stator.
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    p:          int
                Number of electrical poles.
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    
    Returns
    -------
    Tem:        array_like
                Induction machine torque in N*m
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_r = 2*_np.pi*freq
    torque_s = Ls/(omega_r*Rs)
    phi = 1 - Lm**2/(Ls*Lr)
    # Calculate Eigenvalues
    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
    # Calculate pIs0
    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
    # Calculate Constants
    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
    # Calculate ias and Return
    idqs = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
    idqr = C2*_np.exp(lam1*t)+C1*_np.exp(lam2*t)
    # Calculate Lambda
    lamdqr = Lm*idqs+Lr*idqr
    # Calculate Torque
    Tem = Lm/Lr * (lamdqr.real*idqs.imag - lamdqr.imag*idqs.real)
    return(Tem)

# Define Complete Sync. Mach. Fault Current Function
def synmach_ifault(t,Ea,alpha,Xd,Xdp,Xdpp,Xqpp,Tdp,Tdpp,Ta,freq=60):
    &#34;&#34;&#34;
    Synchronous Machine Fault Current Calculator
    
    Given machine parameters, fault inception angle, and time at
    which to calculate fault current, this function will identify
    the complete (symmetrical, asymmetrical, and double frequency)
    fault current.
    
    .. image:: synmach_ifault_formula.png
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    alpha:      float
                Fault inception angle (in degrees)
    Xd:         float
                The Xd (d-axis) reactance in per-unit-ohms
    Xdp:        float
                The X&#34;d (d-axis transient) reactance in
                per-unit-ohms
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Xqpp:       float
                The X&#34;q (q-axis subtransient) reactance in
                per-unit-ohms
    Tdp:        float
                The T&#39;d (d-axis transient) time constant of the
                machine in seconds
    Tdpp:       float
                The T&#34;d (d-axis subtransient) time constant of
                the machine in seconds
    Ta:         float
                Armature short-circuit (DC) time constant in seconds
    freq:       float, optional
                System (electrical) frequency (in degrees),
                default=60
    
    Returns
    -------
    ias:        float
                Synchronous machine fault current (symmetrical,
                asymmetrical, and double frequency component) in
                amps
    &#34;&#34;&#34;
    # Calculate we Component
    we = 2*_np.pi*freq
    # Condition Inputs
    Ea = abs(Ea)
    alpha = _np.radians(alpha)
    # Define Constant Term
    const = _np.sqrt(2)*Ea
    if Xqpp != 0:
        val = 1/Xqpp
    else:
        val = 0
    asym = 1/2*(1/Xdpp+val)*_np.exp(t/Ta)
    # Define Symmetrical Portion
    isym = const*(1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)
               +(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp))*_np.sin(we*t+alpha)
    # Define Asymmetrical Portion
    iasym = const*asym*_np.sin(alpha)
    # Define Double Frequency Term
    idbl = const*1/2*asym*_np.sin(2*we*t+alpha)
    # Compose Complet Current Value
    ias = isym - iasym - idbl
    return(ias)
    
    

# END OF FILE</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="electricpy.fault.busvolt"><code class="name flex">
<span>def <span class="ident">busvolt</span></span>(<span>k, n, Vpf, Z0, Z1, Z2, If, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Faulted Bus Voltage Calculator</p>
<p>This function is designed to calculate the bus voltage(s)
given a specific set of fault characteristics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>
float</code></dt>
<dd>Bus index at which to calculate faulted voltage</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>
float</code></dt>
<dd>Bus index at which fault occurred</dd>
<dt><strong><code>Vpf</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Voltage Pre-Fault, Singular Number</dd>
<dt><strong><code>Z0</code></strong> :&ensp;<code>
ndarray</code></dt>
<dd>Zero-Sequence Impedance Matrix</dd>
<dt><strong><code>Z1</code></strong> :&ensp;<code>
ndarray</code></dt>
<dd>Positive-Sequence Impedance Matrix</dd>
<dt><strong><code>Z2</code></strong> :&ensp;<code>
ndarray</code></dt>
<dd>Negative-Sequence Impedance Matrix</dd>
<dt><strong><code>If</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Sequence Fault Current Evaluated at Bus <em>n</em></dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vf</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Fault Voltage, set of sequence or phase voltages as
specified by <em>sequence</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def busvolt(k,n,Vpf,Z0,Z1,Z2,If,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Faulted Bus Voltage Calculator
    
    This function is designed to calculate the bus voltage(s)
    given a specific set of fault characteristics.
    
    Parameters
    ----------
    k:          float
                Bus index at which to calculate faulted voltage
    n:          float
                Bus index at which fault occurred
    Vpf:        complex
                Voltage Pre-Fault, Singular Number
    Z0:         ndarray
                Zero-Sequence Impedance Matrix
    Z1:         ndarray
                Positive-Sequence Impedance Matrix
    Z2:         ndarray
                Negative-Sequence Impedance Matrix
    If:         complex
                Sequence Fault Current Evaluated at Bus *n*
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Vf:         complex
                The Fault Voltage, set of sequence or phase voltages as
                specified by *sequence*
    &#34;&#34;&#34;
    # Condition Inputs
    k = k-1
    n = n-1
    Z0 = _np.asarray(Z0)
    Z1 = _np.asarray(Z1)
    Z2 = _np.asarray(Z2)
    If = _np.asarray(If)
    # Generate Arrays For Calculation
    Vfmat = _np.array([0, Vpf, 0]).T
    Zmat = _np.array([[Z0[k,n], 0, 0],
                     [0, Z1[k,n], 0],
                     [0, 0, Z2[k,n]]])
    # Perform Calculation
    Vf = Vfmat - Zmat.dot(If)
    if not sequence:
        Vf = _phaseroll( Vf, reference ) # Convert to ABC-Domain
    return(Vf)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.correctedcurrents"><code class="name flex">
<span>def <span class="ident">correctedcurrents</span></span>(<span>Ipri, TAP, correction='Y', CTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Transformer Current Correction Function</p>
<p>Function to evaluate the currents as corrected for microprocessor-
based relay protection schemes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Ipri</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Three-phase set (IA, IB, IC) of primary currents.</dd>
<dt><strong><code>TAP</code></strong> :&ensp;<code>
float</code></dt>
<dd>Relay's TAP setting.</dd>
<dt><strong><code>correction</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>String defining correction factor, may be one of:
(Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
denotes Dab (D1) connection, D- denotes Dac (D11)
connection, and Z (Z12) denotes zero-sequence
removal. default="Y"</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current Transformer Ratio, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Isec_corr</code></strong> :&ensp;<code> list</code> of <code>complex</code></dt>
<dd>The corrected currents to perform operate/restraint
calculations with.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correctedcurrents(Ipri,TAP,correction=&#34;Y&#34;,CTR=1):
    &#34;&#34;&#34;
    Transformer Current Correction Function
    
    Function to evaluate the currents as corrected for microprocessor-
    based relay protection schemes.
    
    Parameters
    ----------
    Ipri:       list of complex
                Three-phase set (IA, IB, IC) of primary currents.
    TAP:        float
                Relay&#39;s TAP setting.
    correction: string, optional
                String defining correction factor, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    CTR:        float
                Current Transformer Ratio, default=1
    
    Returns
    -------
    Isec_corr:  list of complex
                The corrected currents to perform operate/restraint
                calculations with.
    &#34;&#34;&#34;
    # Define Matrix Lookup
    MAT = {   &#34;Y&#34;  : XFMY0,
              &#34;D+&#34; : XFMD1,
              &#34;D-&#34; : XFMD11,
              &#34;Z&#34;  : XFM12}
    # Condition Inputs
    Ipri = _np.asarray(Ipri)
    if isinstance(correction,list):
        mult = MAT[correction[0]]
        for i in correction[1:]:
            mult = mult.dot(MAT[i])
    elif isinstance(correction,str):
        mult = MAT[correction]
    elif isinstance(correction,_np.ndarray):
        mult = correction
    else:
        raise ValueError(&#34;Correction must be string or list of strings.&#34;)
    # Evaluate Corrected Current
    Isec_corr = 1/TAP * mult.dot(Ipri/CTR)
    return(Isec_corr)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.ct_cclass"><code class="name flex">
<span>def <span class="ident">ct_cclass</span></span>(<span>XoR, Imag, Irated, CTR, Rb, Xb, remnance=0, freq=60, ALF=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Transformer (CT) C-Class Function</p>
<p>A function to determine the C-Class rated voltage for a CT.
The formula shown below is used.</p>
<p>[ C_{class}=\frac{(1+\frac{X}{R})<em>\frac{|I_{mag}|}
{I_{rated}</em>CTR}<em>\frac{\left|R_{burden}+j</em>\omega<em>
\frac{X_{burden}}{\omega}\right|</em>100}{V_{rated}}}
{1-remnance} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X-over-R ratio of the system.</dd>
<dt><strong><code>Imag</code></strong> :&ensp;<code>
float</code></dt>
<dd>The (maximum) current magnitude to use for calculation,
typically the fault current.</dd>
<dt><strong><code>Irated</code></strong> :&ensp;<code>
float</code></dt>
<dd>The rated secondary current for the CT.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The CT Ratio (primary/secondary, N) to be used.</dd>
<dt><strong><code>Rb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total burden resistance in ohms.</dd>
<dt><strong><code>Xb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total burden reactance in ohms.</dd>
<dt><strong><code>remnance</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system flux remnance, default=0.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency in Hz, default=60.</dd>
<dt><strong><code>ALF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Saturation Constant which must be satisfied,
default=20.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>c_class</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated C-Class rated voltage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ct_cclass(XoR,Imag,Irated,CTR,Rb,Xb,remnance=0,freq=60,ALF=20):
    &#34;&#34;&#34;
    Current Transformer (CT) C-Class Function
    
    A function to determine the C-Class rated voltage for a CT.
    The formula shown below is used.
    
    .. math::
       C_{class}=\\frac{(1+\\frac{X}{R})*\\frac{|I_{mag}|}
       {I_{rated}*CTR}*\\frac{\\left|R_{burden}+j*\\omega*
       \\frac{X_{burden}}{\\omega}\\right|*100}{V_{rated}}}
       {1-remnance}
    
    Parameters
    ----------
    XoR:        float
                The X-over-R ratio of the system.
    Imag:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    Irated:     float
                The rated secondary current for the CT.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Rb:         float
                The total burden resistance in ohms.
    Xb:         float
                The total burden reactance in ohms.
    remnance:   float, optional
                The system flux remnance, default=0.
    freq:       float, optional
                The system frequency in Hz, default=60.
    ALF:        float, optional
                The Saturation Constant which must be satisfied,
                default=20.
    
    Returns
    -------
    c_class:    float
                The calculated C-Class rated voltage.
    &#34;&#34;&#34;
    # Define omega
    w = 2*_np.pi*freq
    # Find Lb
    Lb = Xb/w
    # Calculate each &#34;term&#34; (multiple)
    t1 = (1+XoR)
    t2 = (Imag/(Irated*CTR))
    t3 = abs(Rb+1j*w*Lb)*100/ALF
    # Evaluate
    Vr_w_rem = t1*t2*t3
    c_class = Vr_w_rem/(1-remnance)
    # Return Result
    return(c_class)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.ct_satratburden"><code class="name flex">
<span>def <span class="ident">ct_satratburden</span></span>(<span>Inom, VArat=None, ANSIv=None, ALF=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Transformer (CT) Saturation at Rated Burden Calculator</p>
<p>A function to determine the Saturation at rated burden.</p>
<p>[
]
where:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Inom</code></strong> :&ensp;<code>
float</code></dt>
<dd>Nominal Current</dd>
<dt><strong><code>VArat</code></strong> :&ensp;<code>
float</code>, optional<code>, exclusive</code></dt>
<dd>The apparent power (VA) rating of the CT.</dd>
<dt><strong><code>ANSIv</code></strong> :&ensp;<code>
float</code>, optional<code>, exclusive</code></dt>
<dd>The ANSI voltage requirement to meet.</dd>
<dt><strong><code>ALF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Accuracy Limit Factor, default=20.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vsat</code></strong> :&ensp;<code>
float</code></dt>
<dd>The saturated voltage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ct_satratburden(Inom,VArat=None,ANSIv=None,ALF=20,):
    &#34;&#34;&#34;
    Current Transformer (CT) Saturation at Rated Burden Calculator
    
    A function to determine the Saturation at rated burden.
    
    .. math:: V_{saturated}=ALF*\\frac{VA_{rated}}{I_{nominal}}
    
    where:
    
    .. math:: VA_{rated}=I_{nominal}*\\frac{ANSI_{voltage}}{20}
    
    Parameters
    ----------
    Inom:       float
                Nominal Current
    VArat:      float, optional, exclusive
                The apparent power (VA) rating of the CT.
    ANSIv:      float, optional, exclusive
                The ANSI voltage requirement to meet.
    ALF:        float, optional
                Accuracy Limit Factor, default=20.
    
    Returns
    -------
    Vsat:       float
                The saturated voltage.
    &#34;&#34;&#34;
    # Validate Inputs
    if VArat == None and ANSIv == None:
        raise ValueError(&#34;VArat or ANSIv must be specified.&#34;)
    elif VArat==None:
        # Calculate VArat from ANSIv
        VArat = Inom*ANSIv/(20)
    # Determine Vsaturation
    Vsat = ALF * VArat/Inom
    return(Vsat)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.ct_saturation"><code class="name flex">
<span>def <span class="ident">ct_saturation</span></span>(<span>XoR, Imag, Vrated, Irated, CTR, Rb, Xb, remnance=0, freq=60, ALF=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Transformer Saturation Calculator</p>
<p>A function to determine the saturation value and a boolean indicator
showing whether or not CT is -in fact- saturated.</p>
<p>To perform this evaluation, we must satisfy the equation:</p>
<p>[ 20\geq(1+\frac{X}{R})<em>\frac{|I_{mag}|}{I_{rated}</em>CTR}
<em>\frac{\left|R_{burden}+j</em>\omega<em>\frac{X_{burden}}
{\omega}\right|</em>100}{V_{rated}*(1-remnanc)} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X-over-R ratio of the system.</dd>
<dt><strong><code>Imag</code></strong> :&ensp;<code>
float</code></dt>
<dd>The (maximum) current magnitude to use for calculation,
typically the fault current.</dd>
<dt><strong><code>Vrated</code></strong> :&ensp;<code>
float</code></dt>
<dd>The rated voltage (accompanying the C-Class value) of
the CT.</dd>
<dt><strong><code>Irated</code></strong> :&ensp;<code>
float</code></dt>
<dd>The rated secondary current for the CT.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The CT Ratio (primary/secondary, N) to be used.</dd>
<dt><strong><code>Rb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total burden resistance in ohms.</dd>
<dt><strong><code>Xb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total burden reactance in ohms.</dd>
<dt><strong><code>remnance</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system flux remnance, default=0.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency in Hz, default=60.</dd>
<dt><strong><code>ALF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Saturation Constant which must be satisfied,
default=20.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated Saturation value.</dd>
<dt><strong><code>saturation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean indicator to mark presence of saturation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ct_saturation(XoR,Imag,Vrated,Irated,CTR,Rb,Xb,remnance=0,freq=60,ALF=20):
    &#34;&#34;&#34;
    Current Transformer Saturation Calculator
    
    A function to determine the saturation value and a boolean indicator
    showing whether or not CT is -in fact- saturated.
    
    To perform this evaluation, we must satisfy the equation:
    
    .. math::
       20\\geq(1+\\frac{X}{R})*\\frac{|I_{mag}|}{I_{rated}*CTR}
       *\\frac{\\left|R_{burden}+j*\\omega*\\frac{X_{burden}}
       {\\omega}\\right|*100}{V_{rated}*(1-remnanc)}
    
    Parameters
    ----------
    XoR:        float
                The X-over-R ratio of the system.
    Imag:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    Vrated:     float
                The rated voltage (accompanying the C-Class value) of
                the CT.
    Irated:     float
                The rated secondary current for the CT.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Rb:         float
                The total burden resistance in ohms.
    Xb:         float
                The total burden reactance in ohms.
    remnance:   float, optional
                The system flux remnance, default=0.
    freq:       float, optional
                The system frequency in Hz, default=60.
    ALF:        float, optional
                The Saturation Constant which must be satisfied,
                default=20.
    
    Returns
    -------
    result:     float
                The calculated Saturation value.
    saturation: bool
                Boolean indicator to mark presence of saturation.
    &#34;&#34;&#34;
    # Define omega
    w = 2*_np.pi*freq
    # Find Lb
    Lb = Xb/w
    # Re-evaluate Vrated
    Vrated = Vrated*(1-remnance)
    # Calculate each &#34;term&#34; (multiple)
    t1 = (1+XoR)
    t2 = (Imag/(Irated*CTR))
    t3 = abs(Rb+1j*w*Lb)*100/Vrated
    # Evaluate
    result = t1*t2*t3
    # Test for saturation
    saturation = result &gt;= ALF
    # Return Results
    return(result,saturation)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.ct_timetosat"><code class="name flex">
<span>def <span class="ident">ct_timetosat</span></span>(<span>Vknee, XoR, Rb, CTR, Imax, ts=None, npts=100, freq=60, plot=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Transformer (CT) Time to Saturation Function</p>
<p>Function to determine the "time to saturate" for an underrated C-Class
CT using three standard curves described by Juergen Holbach.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Vknee</code></strong> :&ensp;<code>
float</code></dt>
<dd>The knee-voltage for the CT.</dd>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X-over-R ratio of the system.</dd>
<dt><strong><code>Rb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total burden resistance in ohms.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The CT Ratio (primary/secondary, N) to be used.</dd>
<dt><strong><code>Imax</code></strong> :&ensp;<code>
float</code></dt>
<dd>The (maximum) current magnitude to use for calculation,
typically the fault current.</dd>
<dt><strong><code>ts</code></strong> :&ensp;<code>
numpy.ndarray</code> or <code>float</code>, optional</dt>
<dd>The time-array or particular (floatint point) time at which
to calculate the values. default=_np.linspace(0,0.1,freq*npts)</dd>
<dt><strong><code>npts</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The number of points (per cycle) to calculate if ts is not
specified, default=100.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency in Hz, default=60.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to enable plotting of calculated curves,
default=False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ct_timetosat(Vknee,XoR,Rb,CTR,Imax,ts=None,npts=100,freq=60,plot=False):
    &#34;&#34;&#34;
    Current Transformer (CT) Time to Saturation Function
    
    Function to determine the &#34;time to saturate&#34; for an underrated C-Class
    CT using three standard curves described by Juergen Holbach.
    
    Parameters
    ----------
    Vknee:      float
                The knee-voltage for the CT.
    XoR:        float
                The X-over-R ratio of the system.
    Rb:         float
                The total burden resistance in ohms.
    CTR:        float
                The CT Ratio (primary/secondary, N) to be used.
    Imax:       float
                The (maximum) current magnitude to use for calculation,
                typically the fault current.
    ts:         numpy.ndarray or float, optional
                The time-array or particular (floatint point) time at which
                to calculate the values. default=_np.linspace(0,0.1,freq*npts)
    npts:       float, optional
                The number of points (per cycle) to calculate if ts is not
                specified, default=100.
    freq:       float, optional
                The system frequency in Hz, default=60.
    plot:       bool, optional
                Control argument to enable plotting of calculated curves,
                default=False.
    &#34;&#34;&#34;
    # Calculate omega
    w = 2*_np.pi*freq
    # Calculate Tp
    Tp = XoR/w
    # If ts isn&#39;t specified, generate it
    if ts==None:
        ts = _np.linspace(0,0.1,freq*npts)
    # Calculate inner term
    term = -XoR*(_np.exp(-ts/Tp)-1)
    # Calculate Vsaturation terms
    Vsat1 = Imax*Rb*(term+1)
    Vsat2 = Imax*Rb*(term-_np.sin(w*ts))
    Vsat3 = Imax*Rb*(1-_np.cos(w*ts))
    # If plotting requested
    if plot and isinstance(ts,_np.ndarray):
        plt.plot(ts,Vsat1,label=&#34;Vsat1&#34;)
        plt.plot(ts,Vsat2,label=&#34;Vsat2&#34;)
        plt.plot(ts,Vsat3,label=&#34;Vsat3&#34;)
        plt.axhline(Vknee,label=&#34;V-knee&#34;,linestyle=&#39;--&#39;)
        plt.title(&#34;Saturation Curves&#34;)
        plt.xlabel(&#34;Time (ts)&#34;)
        plt.legend()
        plt.show()
    elif plot:
        print(&#34;Unable to plot a single point, *ts* must be a numpy-array.&#34;)
    # Determine the crossover points for each saturation curve
    Vsat1c = Vsat2c = Vsat3c = 0
    if isinstance(ts,_np.ndarray):
        for i in range(len(ts)):
            if Vsat1[i]&gt;Vknee and Vsat1c==0:
                Vsat1c = ts[i-1]
            if Vsat2[i]&gt;Vknee and Vsat2c==0:
                Vsat2c = ts[i-1]
            if Vsat3[i]&gt;Vknee and Vsat3c==0:
                Vsat3c = ts[i-1]
        results = (Vsat1c,Vsat2c,Vsat3c)
    else:
        results = (Vsat1,Vsat2,Vsat3)
    return(results)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.ct_vpeak"><code class="name flex">
<span>def <span class="ident">ct_vpeak</span></span>(<span>Zb, Ip, CTR)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Transformer (CT) Peak Voltage Calculator</p>
<p>Simple formula to calculate the Peak Voltage of a CT.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Zb</code></strong> :&ensp;<code>
float</code></dt>
<dd>The burden impedance magnitude (in ohms).</dd>
<dt><strong><code>Ip</code></strong> :&ensp;<code>
float</code></dt>
<dd>The peak current for the CT.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The CTR turns ratio of the CT.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vpeak</code></strong> :&ensp;<code>
float</code></dt>
<dd>The peak voltage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ct_vpeak(Zb,Ip,CTR):
    &#34;&#34;&#34;
    Current Transformer (CT) Peak Voltage Calculator
    
    Simple formula to calculate the Peak Voltage of a CT.
    
    .. math:: \\sqrt{3.5*|Z_burden|*I_{peak}*CTR}
    
    Parameters
    ----------
    Zb:         float
                The burden impedance magnitude (in ohms).
    Ip:         float
                The peak current for the CT.
    CTR:        float
                The CTR turns ratio of the CT.
    
    Returns
    -------
    Vpeak:      float
                The peak voltage.
    &#34;&#34;&#34;
    return(_np.sqrt(3.5*abs(Zb)*Ip*CTR))</code></pre>
</details>
</dd>
<dt id="electricpy.fault.distmeasz"><code class="name flex">
<span>def <span class="ident">distmeasz</span></span>(<span>VLNmeas, If, Ip, Ipp, CTR=1, VTR=1, k0=None, z1=None, z0=None, linelength=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Distance Element Measured Impedance Function</p>
<p>Function to evaluate the Relay-Measured-Impedance as calculated from
the measured voltage, current, and line parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>VLNmeas</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Measured Line-to-Neutral voltage for the
faulted phase in primary volts.</dd>
<dt><strong><code>If</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Faulted phase current measured in primary
amps.</dd>
<dt><strong><code>Ip</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Secondary phase current measured in primary
amps.</dd>
<dt><strong><code>Ipp</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Terchiary phase current measured in primary
amps.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current transformer ratio, default=1</dd>
<dt><strong><code>VTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Voltage transformer ratio, default=1</dd>
<dt><strong><code>k0</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Residual Compensation Factor</dd>
<dt><strong><code>z1</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The positive-sequence impedance
characteristic of the line, specified in
ohms-per-unit where the total line length
(of same unit) is specified in
<em>linelength</em> argument.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The zero-sequence impedance characteristic
of the line, specified in ohms-per-unit
where the total line length (of same unit)
is specified in <em>linelength</em> argument.</dd>
<dt><strong><code>linelength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length (in same base unit as impedance
characteristics) of the line. default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zmeas</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The "measured" impedance as calculated by the relay.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distmeasz(VLNmeas,If,Ip,Ipp,CTR=1,VTR=1,k0=None,z1=None,z0=None,linelength=1):
    &#34;&#34;&#34;
    Distance Element Measured Impedance Function
    
    Function to evaluate the Relay-Measured-Impedance as calculated from
    the measured voltage, current, and line parameters.
    
    Parameters
    ----------
    VLNmeas:    complex
                Measured Line-to-Neutral voltage for the
                faulted phase in primary volts.
    If:         complex
                Faulted phase current measured in primary
                amps.
    Ip:         complex
                Secondary phase current measured in primary
                amps.
    Ipp:        complex
                Terchiary phase current measured in primary
                amps.
    CTR:        float, optional
                Current transformer ratio, default=1
    VTR:        float, optional
                Voltage transformer ratio, default=1
    k0:         complex, optional
                Residual Compensation Factor
    z1:         complex, optional
                The positive-sequence impedance
                characteristic of the line, specified in 
                ohms-per-unit where the total line length
                (of same unit) is specified in
                *linelength* argument.
    z0:         complex, optional
                The zero-sequence impedance characteristic
                of the line, specified in ohms-per-unit
                where the total line length (of same unit)
                is specified in *linelength* argument.
    linelength: float, optional
                The length (in same base unit as impedance
                characteristics) of the line. default=1
    
    Returns
    -------
    Zmeas:      complex
                The &#34;measured&#34; impedance as calculated by the relay.
    &#34;&#34;&#34;
    # Validate Residual Compensation Inputs
    if k0 == z1 == z0 == None:
        raise ValueError(&#34;Residual compensation arguments must be set.&#34;)
    if k0 == None and (z1==None or z0==None):
        raise ValueError(&#34;Both *z1* and *z0* must be specified.&#34;)
    # Calculate Residual Compensation if Necessary
    if k0 == None:
        k0 = residcomp(z1,z0,linelength)
    # Convert Primary Units to Secondary
    V = VLNmeas/VTR
    Ir = (If + Ip + Ipp)/CTR
    I = If/CTR
    # Calculate Measured Impedance
    Zmeas = V / (I+k0*Ir)
    return(Zmeas)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.faultratio"><code class="name flex">
<span>def <span class="ident">faultratio</span></span>(<span>I, Ipickup, CTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Fault Multiple of Pickup (Ratio) Calculator</p>
<p>Evaluates the CTR-scaled pickup measured to
pickup current ratio.</p>
<p>M = meas / pickup</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Measured Current in Amps</dd>
<dt><strong><code>Ipickup</code></strong> :&ensp;<code>
float</code></dt>
<dd>Fault Current Pickup Setting (in Amps)</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio for relay,
default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code>
float</code></dt>
<dd>The measured-to-pickup ratio</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def faultratio(I,Ipickup,CTR=1):
    &#34;&#34;&#34;
    Fault Multiple of Pickup (Ratio) Calculator
    
    Evaluates the CTR-scaled pickup measured to
    pickup current ratio.
    
    M = meas / pickup
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    CTR:        float, optional
                Current Transformer Ratio for relay,
                default=1
    
    Returns
    -------
    M:          float
                The measured-to-pickup ratio
    &#34;&#34;&#34;
    M = I/(CTR * Ipickup)
    return(M)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.genlossfield"><code class="name flex">
<span>def <span class="ident">genlossfield</span></span>(<span>Xd, Xpd, Zbase=1, CTR=1, VTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator Loss of Field Function</p>
<p>Generates the Loss-of-Field Element settings
for a generator using the Xd value and
per-unit base information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xd</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Transient Reactance (Xd) term. May be
specified in ohms or Per-Unit ohms if
<em>Zbase</em> is set.</dd>
<dt><strong><code>Xpd</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Sub-Transient Reactance (X'd) term. May
be specified in ohms or Per-Unit ohms if
<em>Zbase</em> is set.</dd>
<dt><strong><code>Zbase</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Base impedance, used to convert per-unit
Xd and Xpd to secondary values. default=1</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
<dt><strong><code>VTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Voltage Transformer Ratio, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ZoneOff</code></strong> :&ensp;<code>
float</code></dt>
<dd>Zone Offset in ohms.</dd>
<dt><strong><code>Z1dia</code></strong> :&ensp;<code>
float</code></dt>
<dd>Zone 1 diameter in ohms.</dd>
<dt><strong><code>Z2dia</code></strong> :&ensp;<code>
float</code></dt>
<dd>Zone 2 diameter in ohms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genlossfield(Xd,Xpd,Zbase=1,CTR=1,VTR=1):
    &#34;&#34;&#34;
    Generator Loss of Field Function
    
    Generates the Loss-of-Field Element settings
    for a generator using the Xd value and
    per-unit base information.
    
    Parameters
    ----------
    Xd:         float
                The Transient Reactance (Xd) term. May be
                specified in ohms or Per-Unit ohms if
                *Zbase* is set.
    Xpd:        float
                The Sub-Transient Reactance (X&#39;d) term. May
                be specified in ohms or Per-Unit ohms if
                *Zbase* is set.
    Zbase:      float, optional
                Base impedance, used to convert per-unit
                Xd and Xpd to secondary values. default=1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    VTR:        float, optional
                Voltage Transformer Ratio, default=1
    
    Returns
    -------
    ZoneOff:    float
                Zone Offset in ohms.
    Z1dia:      float
                Zone 1 diameter in ohms.
    Z2dia:      float
                Zone 2 diameter in ohms.
    &#34;&#34;&#34;
    # Condition Inputs
    Xd = abs(Xd)
    Xpd = abs(Xpd)
    Zbase = abs(Zbase)
    # Evaluate Xd_sec and Xpd_sec
    Xd_sec = Xd*Zbase*(CTR/VTR)
    Xpd_sec = Xd*Zbase*(CTR/VTR)
    # Determine Zone Offset
    ZoneOff = Xpd_sec/2
    # Evaluate Z1 Diameter and Z2 Diameter
    Z1dia = Zbase*CTR/VTR
    Z2dia = Xd_sec
    # Return
    return(ZoneOff,Z1dia,Z2dia)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.highzmini"><code class="name flex">
<span>def <span class="ident">highzmini</span></span>(<span>N, Ie, Irly=None, Vset=None, Rrly=2000, Imov=0, CTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Minimum Current for High Impedance Protection Calculator</p>
<p>Evaluates the minimum pickup current required to cause
high-impedance bus protection element pickup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>
int</code></dt>
<dd>Number of Current Transformers included in scheme</dd>
<dt><strong><code>Ie</code></strong> :&ensp;<code>
float</code></dt>
<dd>The excitation current at the voltage setting</dd>
<dt><strong><code>Irly</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The relay current at voltage setting</dd>
<dt><strong><code>Vset</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The relay's voltage pickup setting in volts.</dd>
<dt><strong><code>Rrly</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The relay's internal resistance in ohms, default=2000</dd>
<dt><strong><code>Imov</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The overvoltage protection current at the
voltage setting. default=0.0</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Imin</code></strong> :&ensp;<code>
float</code></dt>
<dd>Minimum current required to cause high-impedance
bus protection element pickup.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highzmini(N,Ie,Irly=None,Vset=None,Rrly=2000,Imov=0,CTR=1):
    &#34;&#34;&#34;
    Minimum Current for High Impedance Protection Calculator
    
    Evaluates the minimum pickup current required to cause
    high-impedance bus protection element pickup.
    
    Parameters
    ----------
    N:          int
                Number of Current Transformers included in scheme
    Ie:         float
                The excitation current at the voltage setting
    Irly:       float, optional
                The relay current at voltage setting
    Vset:       float, optional
                The relay&#39;s voltage pickup setting in volts.
    Rrly:       float, optional
                The relay&#39;s internal resistance in ohms, default=2000
    Imov:       float, optional
                The overvoltage protection current at the
                voltage setting. default=0.0
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    Imin:       float
                Minimum current required to cause high-impedance
                bus protection element pickup.
    &#34;&#34;&#34;
    # Validate Inputs
    if Irly == Vset == None:
        raise ValueError(&#34;Relay Current Required.&#34;)
    # Condition Inputs
    Ie = abs(Ie)
    Imov = abs(Imov)
    if Irly == None:
        Vset = abs(Vset)
        Irly = Vset / Rrly
    else:
        Irly = abs(Irly)
    # Evaluate Minimum Current Pickup
    Imin = (N*Ie+Irly+Imov)*CTR
    return(Imin)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.highzvpickup"><code class="name flex">
<span>def <span class="ident">highzvpickup</span></span>(<span>I, RL, Rct, CTR=1, threephase=False, Ks=1.5, Vstd=400, Kd=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>High Impedance Pickup Setting Function</p>
<p>Evaluates the voltage pickup setting for a high
impedance bus protection system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Fault current on primary side (in amps)</dd>
<dt><strong><code>RL</code></strong> :&ensp;<code>
float</code></dt>
<dd>One-way line resistance in ohms</dd>
<dt><strong><code>Rct</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current Transformer Resistance in ohms</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
<dt><strong><code>threephase</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control argument to set the function to
evaluate the result for a three-phase
fault or unbalanced fault. default=False</dd>
<dt><strong><code>Ks</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Security Factor for secure voltage pickup
setting, default=1.5</dd>
<dt><strong><code>Vstd</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>C-Class Voltage rating (i.e. C-400),
default=400</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The dependability factor for dependable
voltage pickup setting, default=0.5</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vsens</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated sensetive voltage-pickup.</dd>
<dt><strong><code>Vdep</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated dependable voltage-pickup.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highzvpickup(I,RL,Rct,CTR=1,threephase=False,Ks=1.5,
                 Vstd=400,Kd=0.5):
    &#34;&#34;&#34;
    High Impedance Pickup Setting Function
    
    Evaluates the voltage pickup setting for a high
    impedance bus protection system.
    
    Parameters
    ----------
    I:          float
                Fault current on primary side (in amps)
    RL:         float
                One-way line resistance in ohms
    Rct:        float
                Current Transformer Resistance in ohms
    CTR:        float, optional
                Current Transformer Ratio, default=1
    threephase: bool, optional
                Control argument to set the function to
                evaluate the result for a three-phase 
                fault or unbalanced fault. default=False
    Ks:         float, optional
                Security Factor for secure voltage pickup
                setting, default=1.5
    Vstd:       float, optional
                C-Class Voltage rating (i.e. C-400),
                default=400
    Kd:         float, optional
                The dependability factor for dependable
                voltage pickup setting, default=0.5
    
    Returns
    -------
    Vsens:      float
                The calculated sensetive voltage-pickup.
    Vdep:       float
                The calculated dependable voltage-pickup.
    &#34;&#34;&#34;
    # Condition Based on threephase Argument
    n = 2
    if threephase: n = 1
    # Evaluate Secure Voltage Pickup
    Vsens = Ks*(n*RL+Rct)*I/CTR
    # Evaluate Dependible Voltage Pickup
    Vdep = Kd*Vstd
    return(Vsens,Vdep)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.indmacheigenvalues"><code class="name flex">
<span>def <span class="ident">indmacheigenvalues</span></span>(<span>Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Eigenvalue Calculator</p>
<p>Calculates the pertinent eigenvalues for an unloaded
induction machine given a specific set of machine
parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Rotor (in Henrys).</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Stator (in Henrys).</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Magnetizing branch
(in Henrys).</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Rotor (in Ohms).</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Stator (in Ohms).</dd>
<dt><strong><code>wrf</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Frequency (in radians/sec) of the rotor slip.
default=0</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Base frequency of the system (in Hertz).
default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lam1</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The First Eigenvalue</dd>
<dt><strong><code>lam2</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Second Eigenvalue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
    &#34;&#34;&#34;
    Induction Machine Eigenvalue Calculator
    
    Calculates the pertinent eigenvalues for an unloaded
    induction machine given a specific set of machine
    parameters.
    
    Parameters
    ----------
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    
    Returns
    -------
    lam1:       complex
                The First Eigenvalue
    lam2:       complex
                The Second Eigenvalue
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_e_base = 2*_np.pi*freq
    omega_rf = wrf
    torque_s = Ls/(omega_e_base*Rs)
    torque_r = Lr/(omega_e_base*Rr)
    alpha = torque_r / torque_s
    phi = 1 - Lm**2/(Ls*Lr)
    omega_r = omega_e_base
    # Calculate k1
    k1 = -1/(2*phi*torque_r)*(1+alpha)
    k1 += 1j*(omega_r/2-omega_rf)
    # Calculate k2
    k2 = 1/(2*phi*torque_r)
    k2 *= _np.sqrt((1+alpha)**2-4*phi*alpha-(omega_r*phi*torque_r)**2
                 +2j*(alpha-1)*omega_r*phi*torque_r)
    # Evaluate Eigenvalues and Return
    lam1 = k1+k2
    lam2 = k1-k2
    return(lam1,lam2)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.indmachphs3sc"><code class="name flex">
<span>def <span class="ident">indmachphs3sc</span></span>(<span>t, Is0, Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60, real=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine 3-Phase SC Calculator</p>
<p>Determines the short-circuit current at
a specified time for a three-phase fault
on an unloaded induction machine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>The time at which to find the
current, may be int, float, or
numpy array.</dd>
<dt><strong><code>Is0</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The initial (t=0) current on
the stator.</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Rotor (in Henrys).</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Stator (in Henrys).</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Magnetizing branch
(in Henrys).</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Rotor (in Ohms).</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Stator (in Ohms).</dd>
<dt><strong><code>wrf</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Frequency (in radians/sec) of the rotor slip.
default=0</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Base frequency of the system (in Hertz).
default=60</dd>
<dt><strong><code>real</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force returned value
to be real part only. default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ias</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>Fault Current</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachphs3sc(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60,real=True):
    &#34;&#34;&#34;
    Induction Machine 3-Phase SC Calculator
    
    Determines the short-circuit current at
    a specified time for a three-phase fault
    on an unloaded induction machine.
    
    Parameters
    ----------
    t:          array_like
                The time at which to find the
                current, may be int, float, or
                numpy array.
    Is0:        complex
                The initial (t=0) current on
                the stator.
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    real:       bool, optional
                Control argument to force returned value
                to be real part only. default=True
    
    Returns
    -------
    ias:        array_like
                Fault Current
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_r = 2*_np.pi*freq
    torque_s = Ls/(omega_r*Rs)
    phi = 1 - Lm**2/(Ls*Lr)
    # Calculate Eigenvalues
    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
    # Calculate pIs0
    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
    # Calculate Constants
    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
    # Calculate ias and Return
    ias = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
    if real:
        ias = _np.real(ias)
    return(ias)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.indmachphs3torq"><code class="name flex">
<span>def <span class="ident">indmachphs3torq</span></span>(<span>t, Is0, Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>The time at which to find the
current, may be int, float, or
numpy array.</dd>
<dt><strong><code>Is0</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The initial (t=0) current on
the stator.</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Rotor (in Henrys).</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Stator (in Henrys).</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance of the Magnetizing branch
(in Henrys).</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Rotor (in Ohms).</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance of the Stator (in Ohms).</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>
int</code></dt>
<dd>Number of electrical poles.</dd>
<dt><strong><code>wrf</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Frequency (in radians/sec) of the rotor slip.
default=0</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Base frequency of the system (in Hertz).
default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Tem</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>Induction machine torque in N*m</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachphs3torq(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
    &#34;&#34;&#34;
    Parameters
    ----------
    t:          array_like
                The time at which to find the
                current, may be int, float, or
                numpy array.
    Is0:        complex
                The initial (t=0) current on
                the stator.
    Lr:         float
                Inductance of the Rotor (in Henrys).
    Ls:         float
                Inductance of the Stator (in Henrys).
    Lm:         float
                Inductance of the Magnetizing branch
                (in Henrys).
    Rr:         float
                Resistance of the Rotor (in Ohms).
    Rs:         float
                Resistance of the Stator (in Ohms).
    p:          int
                Number of electrical poles.
    wrf:        float, optional
                Frequency (in radians/sec) of the rotor slip.
                default=0
    freq:       float, optional
                Base frequency of the system (in Hertz).
                default=60
    
    Returns
    -------
    Tem:        array_like
                Induction machine torque in N*m
    &#34;&#34;&#34;
    # Calculate Required Values
    omega_r = 2*_np.pi*freq
    torque_s = Ls/(omega_r*Rs)
    phi = 1 - Lm**2/(Ls*Lr)
    # Calculate Eigenvalues
    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
    # Calculate pIs0
    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
    # Calculate Constants
    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
    # Calculate ias and Return
    idqs = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
    idqr = C2*_np.exp(lam1*t)+C1*_np.exp(lam2*t)
    # Calculate Lambda
    lamdqr = Lm*idqs+Lr*idqr
    # Calculate Torque
    Tem = Lm/Lr * (lamdqr.real*idqs.imag - lamdqr.imag*idqs.real)
    return(Tem)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.instoc"><code class="name flex">
<span>def <span class="ident">instoc</span></span>(<span>Imin, CTR=1, Ki=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantaneous OverCurrent Pickup Calculator</p>
<p>Using a sensetivity factor and the CTR, evaluates
the secondary-level pickup setting for an
instantaneous overcurrent element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Imin</code></strong> :&ensp;<code>
float</code></dt>
<dd>The minimum fault current in primary amps.</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
<dt><strong><code>Ki</code></strong> :&ensp;<code>
Sensetivity factor</code>, default=<code>0.5</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ipu</code></strong> :&ensp;<code>
float</code></dt>
<dd>The pickup setting for the instantaneous
overcurrent element as referred to the
secondary side.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instoc(Imin,CTR=1,Ki=0.5):
    &#34;&#34;&#34;
    Instantaneous OverCurrent Pickup Calculator
    
    Using a sensetivity factor and the CTR, evaluates
    the secondary-level pickup setting for an
    instantaneous overcurrent element.
    
    Parameters
    ----------
    Imin:       float
                The minimum fault current in primary amps.
    CTR:        float, optional
                Current Transformer Ratio, default=1
    Ki:         Sensetivity factor, default=0.5
    
    Returns
    -------
    Ipu:        float
                The pickup setting for the instantaneous
                overcurrent element as referred to the
                secondary side.
    &#34;&#34;&#34;
    # Evaluate Overcurrent Pickup Setting
    Ipu = Ki * abs(Imin)/CTR
    return(Ipu)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.iopirt"><code class="name flex">
<span>def <span class="ident">iopirt</span></span>(<span>IpriHV, IpriLV, TAPHV, TAPLV, corrHV='Y', corrLV='Y', CTRHV=1, CTRLV=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Operate/Restraint Current Calculator</p>
<p>Calculates the operating current (Iop) and the restraint
current (Irt) as well as the slope.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>IpriHV</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Three-phase set (IA, IB, IC) of primary currents
on the high-voltage side of power transformer.</dd>
</dl>
<p>IpriLV
list of complex
Three-phase set (IA, IB, IC) of primary currents
on the low-voltage side of power transformer.
TAPHV
float
Relay's TAP setting for high-voltage side of
power transformer.
TAPLV
float
Relay's TAP setting for low-voltage side of
power transformer.
corrHV
string, optional
String defining correction factor on high-voltage
side of power transformer, may be one of:
(Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
denotes Dab (D1) connection, D- denotes Dac (D11)
connection, and Z (Z12) denotes zero-sequence
removal. default="Y"
corrLV
string, optional
String defining correction factor on low-voltage
side of power transformer, may be one of:
(Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
denotes Dab (D1) connection, D- denotes Dac (D11)
connection, and Z (Z12) denotes zero-sequence
removal. default="Y"
CTRHV
float
Current Transformer Ratio for high-voltage side
of power transformer, default=1
CTRLV
float
Current Transformer Ratio for low-voltage side
of power transformer, default=1</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Iop</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The operating currents for phases A, B, and C.</dd>
<dt><strong><code>Irt</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The restraint currents for phases A, B, and C.</dd>
<dt><strong><code>slope</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The calculated slopes for phases A, B, and C.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iopirt(IpriHV,IpriLV,TAPHV,TAPLV,corrHV=&#34;Y&#34;,corrLV=&#34;Y&#34;,CTRHV=1,CTRLV=1):
    &#34;&#34;&#34;
    Operate/Restraint Current Calculator
    
    Calculates the operating current (Iop) and the restraint
    current (Irt) as well as the slope.
    
    Parameters
    ----------
    IpriHV:     list of complex
                Three-phase set (IA, IB, IC) of primary currents
                on the high-voltage side of power transformer.
    IpriLV      list of complex
                Three-phase set (IA, IB, IC) of primary currents
                on the low-voltage side of power transformer.
    TAPHV       float
                Relay&#39;s TAP setting for high-voltage side of
                power transformer.
    TAPLV       float
                Relay&#39;s TAP setting for low-voltage side of
                power transformer.
    corrHV      string, optional
                String defining correction factor on high-voltage
                side of power transformer, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    corrLV      string, optional
                String defining correction factor on low-voltage
                side of power transformer, may be one of:
                (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                denotes Dab (D1) connection, D- denotes Dac (D11)
                connection, and Z (Z12) denotes zero-sequence
                removal. default=&#34;Y&#34;
    CTRHV       float
                Current Transformer Ratio for high-voltage side
                of power transformer, default=1
    CTRLV       float
                Current Transformer Ratio for low-voltage side
                of power transformer, default=1
    
    Returns
    -------
    Iop:        list of float
                The operating currents for phases A, B, and C.
    Irt:        list of float
                The restraint currents for phases A, B, and C.
    slope:      list of float
                The calculated slopes for phases A, B, and C.
    &#34;&#34;&#34;
    # Calculate Corrected Currents
    IcorHV = correctedcurrents(IpriHV,TAPHV,corrHV,CTRHV)
    IcorLV = correctedcurrents(IpriLV,TAPLV,corrLV,CTRLV)
    # Calculate Operate/Restraint Currents
    Iop = _np.absolute( IcorHV + IcorLV )
    Irt = _np.absolute(IcorHV) + _np.absolute(IcorLV)
    # Calculate Slopes
    slope = Iop/Irt
    return(Iop,Irt,slope)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs1g"><code class="name flex">
<span>def <span class="ident">phs1g</span></span>(<span>Vth, Zseq, Rf=0, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Single-Phase-to-Ground Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a single-line-to-ground fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex,</code></dt>
<dd>The Array of Fault Currents as (If0, If1, If2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs1g(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single-Phase-to-Ground Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single-line-to-ground fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
    
    .. math:: I_2 = I_1
    
    .. math:: I_0 = I_1
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Current
    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
    Ifault = _np.array([ Ifault, Ifault, Ifault ])
    # Prepare Value for return
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    # Return Value
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs1mvasc"><code class="name flex">
<span>def <span class="ident">phs1mvasc</span></span>(<span>Vth, Zseq, Rf=0, Sbase=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Single-Phase MVA Short-Circuit Calculator</p>
<p>Calculator to evaluate the Short-Circuit MVA of a single-phase fault given the system
parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:</p>
<p>[
]
where:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>Sbase</code></strong> :&ensp;<code>
real</code>, optional</dt>
<dd>The per-unit base for power. default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>MVA</code></strong> :&ensp;<code>
real</code></dt>
<dd>Single-Phase Short-Circuit MVA.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs1mvasc(Vth,Zseq,Rf=0,Sbase=1):
    &#34;&#34;&#34;
    Single-Phase MVA Short-Circuit Calculator
    
    Calculator to evaluate the Short-Circuit MVA of a single-phase fault given the system
    parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
    
    .. math:: MVA_{sc} = \\left|I_1^2\\right|*|Z_1| * Sbase
    
    where:
    
    .. math:: I_1 = \\frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    Sbase:      real, optional
                The per-unit base for power. default=1
    
    Returns
    -------
    MVA:        real
                Single-Phase Short-Circuit MVA.
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Current
    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
    # Calculate MVA
    MVA = abs(Ifault)**2 * abs(X1) * Sbase
    # Scale VA to MVA if Sbase is not 1
    if Sbase != 1:
        MVA = MVA * 1e-6 # Divide by 1e6 (M)
    # Return
    return(MVA)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs2"><code class="name flex">
<span>def <span class="ident">phs2</span></span>(<span>Vth, Zseq, Rf=0, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Line-to-Line Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a phase-to-phase fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex,</code></dt>
<dd>The Array of Fault Currents as (If0, If1, If2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs2(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Line-to-Line Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a phase-to-phase fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+Z_2+R_f}
    
    .. math:: I_2 = -I_1
    
    .. math:: I_0 = 0
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If0 = 0
    If1 = Vth / (X1 + X2 + Rf)
    If2 = -If1
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs2g"><code class="name flex">
<span>def <span class="ident">phs2g</span></span>(<span>Vth, Zseq, Rf=0, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Double-Line-to-Ground Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a double-line-to-ground fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex,</code></dt>
<dd>The Array of Fault Currents as (If0, If1, If2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs2g(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Double-Line-to-Ground Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a double-line-to-ground fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+\\frac{Z_2*(Z_0+3*R_f)}{Z_0+Z_2+3*R_f}}
    
    .. math:: I_2 = -\\frac{V_{th}-Z_1*I_1}{X_2}
    
    .. math:: I_0 = -\\frac{V_{th}-Z_1*I_1}{X_0+3*R_f}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + (X2*(X0+3*Rf))/(X0+X2+3*Rf))
    If2 = -(Vth - X1*If1)/X2
    If0 = -(Vth - X1*If1)/(X0+3*Rf)
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs3"><code class="name flex">
<span>def <span class="ident">phs3</span></span>(<span>Vth, Zseq, Rf=0, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Three-Phase Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a three-phase fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>The Fault Current, equal for 0, pos., and neg. seq.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs3(Vth,Zseq,Rf=0,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Three-Phase Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a three-phase fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+R_1}
    
    .. math:: I_2 = 0
    
    .. math:: I_0 = 0
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex
                The Fault Current, equal for 0, pos., and neg. seq.
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X1, complex)): X1 *= 1j
    # Calculate Fault Currents
    Ifault = Vth/(X1 + Rf)
    Ifault = _np.array([ 0, Ifault, 0 ])
    # Prepare to Return Value
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.phs3mvasc"><code class="name flex">
<span>def <span class="ident">phs3mvasc</span></span>(<span>Vth, Zseq, Rf=0, Sbase=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Three-Phase MVA Short-Circuit Calculator</p>
<p>Calculator to evaluate the Short-Circuit MVA of a three-phase fault given the system
parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>Rf</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The fault resistance, default=0</dd>
<dt><strong><code>Sbase</code></strong> :&ensp;<code>
real</code>, optional</dt>
<dd>The per-unit base for power. default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>MVA</code></strong> :&ensp;<code>
real</code></dt>
<dd>Three-Phase Short-Circuit MVA.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs3mvasc(Vth,Zseq,Rf=0,Sbase=1):
    &#34;&#34;&#34;
    Three-Phase MVA Short-Circuit Calculator
    
    Calculator to evaluate the Short-Circuit MVA of a three-phase fault given the system
    parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
    
    .. math:: MVA_{sc} = \\frac{\\left|V_{th}^2\\right|}{|Z_1|} * Sbase
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    Rf:         complex, optional
                The fault resistance, default=0
    Sbase:      real, optional
                The per-unit base for power. default=1
    
    Returns
    -------
    MVA:        real
                Three-Phase Short-Circuit MVA.
    &#34;&#34;&#34;
    # Calculate Three-Phase MVA
    MVA = abs(Vth)**2 / abs(Zseq[1]) * Sbase
    # Scale VA to MVA if Sbase is not 1
    if Sbase != 1:
        MVA = MVA * 1e-6 # Divide by 1e6 (M)
    # Return
    return(MVA)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.pickup"><code class="name flex">
<span>def <span class="ident">pickup</span></span>(<span>Iloadmax, Ifaultmin, scale=0, printout=False, units='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Current Pickup Selection Assistant</p>
<p>Used to assist in evaluating an optimal phase-over-current pickup
setting. Uses maximum load and minimum fault current to provide
user assistance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Iloadmax</code></strong> :&ensp;<code>
float</code></dt>
<dd>The maximum load current in amps.</dd>
<dt><strong><code>Ifaultmin</code></strong> :&ensp;<code> float</code></dt>
<dd>The minimum fault current in amps.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control scaling to set number of significant figures.
default=0</dd>
<dt><strong><code>printout</code></strong> :&ensp;<code>
boolean</code>, optional</dt>
<dd>Control argument to enable printing of intermediate
stages, default=False.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>String to be appended to any printed output denoting
the units of which are being printed, default="A"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>setpoint</code></strong> :&ensp;<code>
float</code></dt>
<dd>The evaluated setpoint at which the function suggests
the phase-over-current pickup setting be placed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickup(Iloadmax,Ifaultmin,scale=0,printout=False,units=&#34;A&#34;):
    &#34;&#34;&#34;
    Current Pickup Selection Assistant
    
    Used to assist in evaluating an optimal phase-over-current pickup
    setting. Uses maximum load and minimum fault current to provide
    user assistance.
    
    Parameters
    ----------
    Iloadmax:   float
                The maximum load current in amps.
    Ifaultmin:  float
                The minimum fault current in amps.
    scale:      int, optional
                Control scaling to set number of significant figures.
                default=0
    printout:   boolean, optional
                Control argument to enable printing of intermediate
                stages, default=False.
    units:      string, optional
                String to be appended to any printed output denoting
                the units of which are being printed, default=&#34;A&#34;
    
    Returns
    -------
    setpoint:   float
                The evaluated setpoint at which the function suggests
                the phase-over-current pickup setting be placed.
    &#34;&#34;&#34;
    IL2 = 2*Iloadmax
    IF2 = Ifaultmin/2
    exponent = len(str(IL2).split(&#39;.&#39;)[0])
    setpoint = _np.ceil(IL2*10**(-exponent+1+scale))*10**(exponent-1-scale)
    if printout:
        print(&#34;Range Min:&#34;,IL2,units,&#34;\t\tRange Max:&#34;,IF2,units)
    if IF2 &lt; setpoint:
        setpoint = IL2
        if IL2 &gt; IF2:
            raise ValueError(&#34;Invalid Parameters.&#34;)
    if printout:
        print(&#34;Current Pickup:&#34;,setpoint,units)
    return(setpoint)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.pktransrecvolt"><code class="name flex">
<span>def <span class="ident">pktransrecvolt</span></span>(<span>C, L, R=0, VLL=None, VLN=None, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Peak Transient Recovery Function</p>
<p>Peak Transient Recovery Voltage calculation
function, evaluates the peak transient
recovery voltage (restriking voltage) and
the Rate-of-Rise-Recovery Voltage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance Value in Farads.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance in Henries.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The resistance of the system used for
calculation, default=0.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>Line-to-Line voltage, exclusive
optional argument.</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>Line-to-Neutral voltage, exclusive
optional argument.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency in Hz.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vcpk</code></strong> :&ensp;<code>
float</code></dt>
<dd>Peak Transient Recovery Voltage in volts.</dd>
<dt><strong><code>RRRV</code></strong> :&ensp;<code>
float</code></dt>
<dd>The RRRV (Rate-of-Rise-Recovery Voltage)
calculated given the parameters in volts
per second.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pktransrecvolt(C,L,R=0,VLL=None,VLN=None,freq=60):
    &#34;&#34;&#34;
    Peak Transient Recovery Function
    
    Peak Transient Recovery Voltage calculation
    function, evaluates the peak transient
    recovery voltage (restriking voltage) and
    the Rate-of-Rise-Recovery Voltage.
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    R:          float, optional
                The resistance of the system used for
                calculation, default=0.
    VLL:        float, exclusive
                Line-to-Line voltage, exclusive
                optional argument.
    VLN:        float, exclusive
                Line-to-Neutral voltage, exclusive
                optional argument.
    freq:       float, optional
                System frequency in Hz.
    
    Returns
    -------
    Vcpk:       float
                Peak Transient Recovery Voltage in volts.
    RRRV:       float
                The RRRV (Rate-of-Rise-Recovery Voltage)
                calculated given the parameters in volts
                per second.
    &#34;&#34;&#34;
    # Evaluate alpha, omega-n, and fn
    alpha = R/(2*L)
    wn = 1/_np.sqrt(L*C) - alpha
    fn = wn/(2*_np.pi)
    # Evaluate Vm
    if VLL!=None:
        Vm = _np.sqrt(2/3)*VLL
    elif VLN!=None:
        Vm = _np.sqrt(2)*VLN
    else:
        raise ValueError(&#34;One voltage must be specified.&#34;)
    # Evaluate Vcpk (worst case)
    Vcpk = wn**2/(wn**2-2*_np.pi*freq)*Vm*2
    # Evaluate RRRV
    RRRV = 2*Vm*fn/0.5
    return(Vcpk,RRRV)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.poleopen1"><code class="name flex">
<span>def <span class="ident">poleopen1</span></span>(<span>Vth, Zseq, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Single Pole Open Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a single pole open fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference, or the
faulted phase indicator; default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex,</code></dt>
<dd>The Array of Fault Currents as (If0, If1, If2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poleopen1(Vth,Zseq,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single Pole Open Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single pole open fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+(\\frac{1}{Z_2}+\\frac{1}{Z_0})^-1}
    
    .. math:: I_2 = -I_1 * \\frac{Z_0}{Z_2+Z_0}
    
    .. math:: I_0 = -I_1 * \\frac{Z_2}{Z_2+Z_0}
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference, or the
                faulted phase indicator; default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + (1/X2 + 1/X0)**(-1))
    If2 = -If1 * X0/(X2 + X0)
    If0 = -If1 * X2/(X2 + X0)
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.poleopen2"><code class="name flex">
<span>def <span class="ident">poleopen2</span></span>(<span>Vth, Zseq, sequence=True, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Single Pole Open Fault Calculator</p>
<p>This function will evaluate the Zero, Positive, and Negative
sequence currents for a single pole open fault.</p>
<p>[
]
[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Thevenin-Equivalent-Voltage</dd>
<dt><strong><code>Zseq</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Tupple of sequence reactances as (Z0, Z1, Z2)</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return into symmetrical-
or phase-domain values.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference, or the
faulted phase indicator; default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ifault</code></strong> :&ensp;<code>
list</code> of <code>complex,</code></dt>
<dd>The Array of Fault Currents as (If0, If1, If2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poleopen2(Vth,Zseq,sequence=True,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Single Pole Open Fault Calculator
    
    This function will evaluate the Zero, Positive, and Negative
    sequence currents for a single pole open fault.
    
    .. math:: I_1 = \\frac{V_{th}}{Z_1+Z_2+Z_0}
    
    .. math:: I_2 = I_1
    
    .. math:: I_0 = I_1
    
    Parameters
    ----------
    Vth:        complex
                The Thevenin-Equivalent-Voltage
    Zseq:       list of complex
                Tupple of sequence reactances as (Z0, Z1, Z2)
    sequence:   bool, optional
                Control argument to force return into symmetrical-
                or phase-domain values.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference, or the
                faulted phase indicator; default=&#39;A&#39;
    
    Returns
    -------
    Ifault:     list of complex,
                The Array of Fault Currents as (If0, If1, If2)
    &#34;&#34;&#34;
    # Decompose Reactance Tuple
    X0, X1, X2 = Zseq
    # Ensure that X-components are imaginary
    if(not isinstance(X0, complex)): X0 *= 1j
    if(not isinstance(X1, complex)): X1 *= 1j
    if(not isinstance(X2, complex)): X2 *= 1j
    # Calculate Fault Currents
    If1 = Vth / (X1 + X2 + X0)
    If2 = If1
    If0 = If1
    Ifault = _np.array([If0, If1, If2])
    # Return Currents
    if not sequence:
        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
    return(Ifault)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.protectiontap"><code class="name flex">
<span>def <span class="ident">protectiontap</span></span>(<span>S, CTR=1, VLN=None, VLL=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Protection TAP Setting Calculator</p>
<p>Evaluates the required TAP setting based on the rated power of
a transformer (the object being protected) and the voltage
(either primary or secondary) in conjunction with the CTR
(current transformer ratio) for the side in question (primary/
secondary).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Current Transformer Ratio.</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rated apparent power magnitude (VA/VAR/W).</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>Line-to-Neutral voltage in volts.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>Line-to-Line voltage in volts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>TAP</code></strong> :&ensp;<code>
float</code></dt>
<dd>The TAP setting required to meet the specifications.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protectiontap(S,CTR=1,VLN=None,VLL=None):
    &#34;&#34;&#34;
    Protection TAP Setting Calculator
    
    Evaluates the required TAP setting based on the rated power of
    a transformer (the object being protected) and the voltage
    (either primary or secondary) in conjunction with the CTR
    (current transformer ratio) for the side in question (primary/
    secondary).
    
    Parameters
    ----------
    CTR:        float
                The Current Transformer Ratio.
    S:          float
                Rated apparent power magnitude (VA/VAR/W).
    VLN:        float, exclusive
                Line-to-Neutral voltage in volts.
    VLL:        float, exclusive
                Line-to-Line voltage in volts.
    
    Returns
    -------
    TAP:        float
                The TAP setting required to meet the specifications.
    &#34;&#34;&#34;
    # Condition Voltage(s)
    if VLL != None:
        V = abs(_np.sqrt(3)*VLL)
    elif VLN != None:
        V = abs(3 * VLN)
    else:
        raise ValueError(&#34;One or more voltages must be provided.&#34;)
    # Calculate TAP
    TAP = abs(S) / (V*CTR)
    return(TAP)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.residcomp"><code class="name flex">
<span>def <span class="ident">residcomp</span></span>(<span>z1, z0, linelength=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Residual Compensation Factor Function</p>
<p>Evaluates the residual compensation factor based on
the line's positive and zero sequence impedance
characteristics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z1</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The positive-sequence impedance
characteristic of the line, specified in
ohms-per-unit where the total line length
(of same unit) is specified in
<em>linelength</em> argument.</dd>
<dt><strong><code>z0</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The zero-sequence impedance characteristic
of the line, specified in ohms-per-unit
where the total line length (of same unit)
is specified in <em>linelength</em> argument.</dd>
<dt><strong><code>linelength</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length (in same base unit as impedance
characteristics) of the line. default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>k0</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The residual compensation factor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def residcomp(z1,z0,linelength=1):
    &#34;&#34;&#34;
    Residual Compensation Factor Function
    
    Evaluates the residual compensation factor based on
    the line&#39;s positive and zero sequence impedance
    characteristics.
    
    Parameters
    ----------
    z1:         complex
                The positive-sequence impedance
                characteristic of the line, specified in 
                ohms-per-unit where the total line length
                (of same unit) is specified in
                *linelength* argument.
    z0:         complex
                The zero-sequence impedance characteristic
                of the line, specified in ohms-per-unit
                where the total line length (of same unit)
                is specified in *linelength* argument.
    linelength: float, optional
                The length (in same base unit as impedance
                characteristics) of the line. default=1
    
    Returns
    -------
    k0:         complex
                The residual compensation factor.
    &#34;&#34;&#34;
    # Evaluate Z1L and Z0L
    Z1L = z1*linelength
    Z0L = z0*linelength
    # Calculate Residual Compensation Factor (k0)
    k0 = (Z0L - Z1L)/(3*Z1L)
    return(k0)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.scMVA"><code class="name flex">
<span>def <span class="ident">scMVA</span></span>(<span>Zth=None, Isc=None, Vth=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Short-Circuit MVA Calculator</p>
<p>Function defines a method of interpretively
calculating the short-circuit MVA value
given two of the three arguments. The formulas
are all based around the following:</p>
<p>[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Thevenin-Equivalent-Impedance</dd>
<dt><strong><code>Isc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Short-Circuit-Current, if left as
None, will force function to use
default setting for Vth.
default=None</dd>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Thevenin-Equivalent-Voltage,
defaults to a 1-per-unit value.
default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>MVA</code></strong> :&ensp;<code>
float</code></dt>
<dd>Short-Circuit MVA, not described
as three-phase or otherwise, such
determination is dependent upon
inputs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scMVA(Zth=None,Isc=None,Vth=1):
    &#34;&#34;&#34;
    Simple Short-Circuit MVA Calculator
    
    Function defines a method of interpretively
    calculating the short-circuit MVA value
    given two of the three arguments. The formulas
    are all based around the following:
    
    .. math:: MVA_{sc} = V_{th}*I_{sc}
    
    .. math:: V_{th} = I_{sc}*Z_{th}
    
    Parameters
    ----------
    Zth:        float
                The Thevenin-Equivalent-Impedance
    Isc:        float, optional
                Short-Circuit-Current, if left as
                None, will force function to use
                default setting for Vth.
                default=None
    Vth:        float, optional
                The Thevenin-Equivalent-Voltage,
                defaults to a 1-per-unit value.
                default=1
    
    Returns
    -------
    MVA:        float
                Short-Circuit MVA, not described
                as three-phase or otherwise, such
                determination is dependent upon
                inputs.
    &#34;&#34;&#34;
    # Test for too few inputs
    if not any((Zth,Isc)):
        raise ValueError(&#34;Either Zth or Isc must be specified.&#34;)
    # Condition Inputs
    if Zth is not None:
        Zth = abs(Zth)
    if Isc is not None:
        Isc = abs(Isc)
    if Vth != 1:
        Vth = abs(Vth)
    # Calculate MVA from one of the available methods
    if all((Zth,Isc)):
        MVA = Isc**2 * Zth
    elif all((Zth,Vth)):
        MVA = Vth**2 / Zth
    else:
        MVA = Vth * Isc
    # Return Value
    return(MVA)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.symrmsfaultcur"><code class="name flex">
<span>def <span class="ident">symrmsfaultcur</span></span>(<span>V, R, X, t=0.016666666666666666, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Symmetrical/RMS Current Calculator</p>
<p>Function to evaluate the time-constant tau,
the symmetrical fault current, and the RMS
current for a faulted circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage magnitude at fault point,
not described as line-to-line or
line-to-neutral.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>The fault resistance in ohms.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>
float</code></dt>
<dd>The fault impedance in ohms.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The time in seconds.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency in Hz.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tau</code></strong> :&ensp;<code>
float</code></dt>
<dd>The time-constant tau in seconds.</dd>
<dt><strong><code>Isym</code></strong> :&ensp;<code>
float</code></dt>
<dd>Symmetrical fault current in amps.</dd>
<dt><strong><code>Irms</code></strong> :&ensp;<code>
float</code></dt>
<dd>RMS fault current in amps.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symrmsfaultcur(V,R,X,t=1/60,freq=60):
    &#34;&#34;&#34;
    Symmetrical/RMS Current Calculator
    
    Function to evaluate the time-constant tau,
    the symmetrical fault current, and the RMS
    current for a faulted circuit.
    
    Parameters
    ----------
    V:          float
                Voltage magnitude at fault point,
                not described as line-to-line or
                line-to-neutral.
    R:          float
                The fault resistance in ohms.
    X:          float
                The fault impedance in ohms.
    t:          float, optional
                The time in seconds.
    freq:       float, optional
                The system frequency in Hz.
    
    Returns
    -------
    tau:        float
                The time-constant tau in seconds.
    Isym:       float
                Symmetrical fault current in amps.
    Irms:       float
                RMS fault current in amps.
    &#34;&#34;&#34;
    # Calculate Z and tau
    Z = _np.sqrt(R**2+X**2)
    tau = X/(2*_np.pi*freq*R)
    # Calculate Symmetrical Fault Current
    Isym = (V/_np.sqrt(3))/Z
    # Calculate RMS Fault Current
    Irms = _np.sqrt(1+2*_np.exp(-2*t/tau))*Isym
    return(tau,Isym,Irms)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.synmach_Iasym"><code class="name flex">
<span>def <span class="ident">synmach_Iasym</span></span>(<span>t, Eq, Xdpp, Xqpp, Ta)</span>
</code></dt>
<dd>
<div class="desc"><p>Synch. Machine Asymmetrical Fault Current Calc.</p>
<p>Determines the asymmetrical fault current of a synchronous
machine given the machine parameters, the internal voltage,
and the time for which to calculate.</p>
<p>[ \left(\frac{1}{X"_d}+\frac{1}{X"_q}\right)e^{\frac{-t}
{T_a}} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate the fault current</dd>
<dt><strong><code>Eq</code></strong> :&ensp;<code>
float</code></dt>
<dd>The internal machine voltage in per-unit-volts</dd>
<dt><strong><code>Xdpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"d (d-axis subtransient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Xqpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"q (q-axis subtransient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Ta</code></strong> :&ensp;<code>
float</code></dt>
<dd>Armature short-circuit (DC) time constant in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Iasym</code></strong> :&ensp;<code>
float</code></dt>
<dd>Peak asymmetrical fault current in per-unit-amps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synmach_Iasym(t,Eq,Xdpp,Xqpp,Ta):
    &#34;&#34;&#34;
    Synch. Machine Asymmetrical Fault Current Calc.
    
    Determines the asymmetrical fault current of a synchronous
    machine given the machine parameters, the internal voltage,
    and the time for which to calculate.
    
    .. math:: I_{asym}=\\sqrt{2}\\left|E_q\\right|\\frac{1}{2}
       \\left(\\frac{1}{X&#34;_d}+\\frac{1}{X&#34;_q}\\right)e^{\\frac{-t}
       {T_a}}
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Xqpp:       float
                The X&#34;q (q-axis subtransient) reactance in
                per-unit-ohms
    Ta:         float
                Armature short-circuit (DC) time constant in seconds
    
    Returns
    -------
    Iasym:      float
                Peak asymmetrical fault current in per-unit-amps
    &#34;&#34;&#34;
    # Calculate Time Constant Term
    t_c = 1/Xdpp + 1/Xqpp
    # Calculate Asymmetrical Current
    Iasym = _np.sqrt(2)*abs(Eq)*1/2*t_c*_np.exp(-t/Ta)
    return(Iasym)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.synmach_Isym"><code class="name flex">
<span>def <span class="ident">synmach_Isym</span></span>(<span>t, Eq, Xd, Xdp, Xdpp, Tdp, Tdpp)</span>
</code></dt>
<dd>
<div class="desc"><p>Synch. Machine Symmetrical Fault Current Calc.</p>
<p>Determines the Symmetrical Fault Current of a synchronous
machine given the machine parameters, the internal voltage,
and the time for which to calculate.</p>
<p>[ \frac{1}{X_d}+\left(\frac{1}{X'_d}-\frac{1}{X_d}
\right)\cdot e^{\frac{-t}{T'_d}}+\left(\frac{1}
{X"_d}-\frac{1}{X'_d}\right)\cdot e^{\frac{-t}{T"_d}}
\right] ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate the fault current</dd>
<dt><strong><code>Eq</code></strong> :&ensp;<code>
float</code></dt>
<dd>The internal machine voltage in per-unit-volts</dd>
<dt><strong><code>Xd</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Xd (d-axis) reactance in per-unit-ohms</dd>
<dt><strong><code>Xdp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"d (d-axis transient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Xdpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"d (d-axis subtransient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Tdp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The T'd (d-axis transient) time constant of the
machine in seconds</dd>
<dt><strong><code>Tdpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The T"d (d-axis subtransient) time constant of
the machine in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ia</code></strong> :&ensp;<code>
float</code></dt>
<dd>Peak symmetrical fault current in per-unit-amps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synmach_Isym(t,Eq,Xd,Xdp,Xdpp,Tdp,Tdpp):
    &#34;&#34;&#34;
    Synch. Machine Symmetrical Fault Current Calc.
    
    Determines the Symmetrical Fault Current of a synchronous
    machine given the machine parameters, the internal voltage,
    and the time for which to calculate.
    
    .. math:: I_a(t)=\\sqrt{2}\\left|E_q\\right|\\left[
       \\frac{1}{X_d}+\\left(\\frac{1}{X&#39;_d}-\\frac{1}{X_d}
       \\right)\\cdot e^{\\frac{-t}{T&#39;_d}}+\\left(\\frac{1}
       {X&#34;_d}-\\frac{1}{X&#39;_d}\\right)\\cdot e^{\\frac{-t}{T&#34;_d}}
       \\right]
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    Xd:         float
                The Xd (d-axis) reactance in per-unit-ohms
    Xdp:        float
                The X&#34;d (d-axis transient) reactance in
                per-unit-ohms
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Tdp:        float
                The T&#39;d (d-axis transient) time constant of the
                machine in seconds
    Tdpp:       float
                The T&#34;d (d-axis subtransient) time constant of
                the machine in seconds
    
    Returns
    -------
    Ia:         float
                Peak symmetrical fault current in per-unit-amps
    &#34;&#34;&#34;
    # Calculate Time-Constant Term
    t_c = 1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)+(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp)
    # Calculate Fault Current
    Ia = _np.sqrt(2)*abs(Eq)*t_c
    return(Ia)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.synmach_ifault"><code class="name flex">
<span>def <span class="ident">synmach_ifault</span></span>(<span>t, Ea, alpha, Xd, Xdp, Xdpp, Xqpp, Tdp, Tdpp, Ta, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronous Machine Fault Current Calculator</p>
<p>Given machine parameters, fault inception angle, and time at
which to calculate fault current, this function will identify
the complete (symmetrical, asymmetrical, and double frequency)
fault current.</p>
<p><img alt="" src="synmach_ifault_formula.png"></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate the fault current</dd>
<dt><strong><code>Eq</code></strong> :&ensp;<code>
float</code></dt>
<dd>The internal machine voltage in per-unit-volts</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>
float</code></dt>
<dd>Fault inception angle (in degrees)</dd>
<dt><strong><code>Xd</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Xd (d-axis) reactance in per-unit-ohms</dd>
<dt><strong><code>Xdp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"d (d-axis transient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Xdpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"d (d-axis subtransient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Xqpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X"q (q-axis subtransient) reactance in
per-unit-ohms</dd>
<dt><strong><code>Tdp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The T'd (d-axis transient) time constant of the
machine in seconds</dd>
<dt><strong><code>Tdpp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The T"d (d-axis subtransient) time constant of
the machine in seconds</dd>
<dt><strong><code>Ta</code></strong> :&ensp;<code>
float</code></dt>
<dd>Armature short-circuit (DC) time constant in seconds</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency (in degrees),
default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ias</code></strong> :&ensp;<code>
float</code></dt>
<dd>Synchronous machine fault current (symmetrical,
asymmetrical, and double frequency component) in
amps</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synmach_ifault(t,Ea,alpha,Xd,Xdp,Xdpp,Xqpp,Tdp,Tdpp,Ta,freq=60):
    &#34;&#34;&#34;
    Synchronous Machine Fault Current Calculator
    
    Given machine parameters, fault inception angle, and time at
    which to calculate fault current, this function will identify
    the complete (symmetrical, asymmetrical, and double frequency)
    fault current.
    
    .. image:: synmach_ifault_formula.png
    
    Parameters
    ----------
    t:          float
                Time at which to calculate the fault current
    Eq:         float
                The internal machine voltage in per-unit-volts
    alpha:      float
                Fault inception angle (in degrees)
    Xd:         float
                The Xd (d-axis) reactance in per-unit-ohms
    Xdp:        float
                The X&#34;d (d-axis transient) reactance in
                per-unit-ohms
    Xdpp:       float
                The X&#34;d (d-axis subtransient) reactance in
                per-unit-ohms
    Xqpp:       float
                The X&#34;q (q-axis subtransient) reactance in
                per-unit-ohms
    Tdp:        float
                The T&#39;d (d-axis transient) time constant of the
                machine in seconds
    Tdpp:       float
                The T&#34;d (d-axis subtransient) time constant of
                the machine in seconds
    Ta:         float
                Armature short-circuit (DC) time constant in seconds
    freq:       float, optional
                System (electrical) frequency (in degrees),
                default=60
    
    Returns
    -------
    ias:        float
                Synchronous machine fault current (symmetrical,
                asymmetrical, and double frequency component) in
                amps
    &#34;&#34;&#34;
    # Calculate we Component
    we = 2*_np.pi*freq
    # Condition Inputs
    Ea = abs(Ea)
    alpha = _np.radians(alpha)
    # Define Constant Term
    const = _np.sqrt(2)*Ea
    if Xqpp != 0:
        val = 1/Xqpp
    else:
        val = 0
    asym = 1/2*(1/Xdpp+val)*_np.exp(t/Ta)
    # Define Symmetrical Portion
    isym = const*(1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)
               +(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp))*_np.sin(we*t+alpha)
    # Define Asymmetrical Portion
    iasym = const*asym*_np.sin(alpha)
    # Define Double Frequency Term
    idbl = const*1/2*asym*_np.sin(2*we*t+alpha)
    # Compose Complet Current Value
    ias = isym - iasym - idbl
    return(ias)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.tdradial"><code class="name flex">
<span>def <span class="ident">tdradial</span></span>(<span>I, CTI, Ipu_up, Ipu_dn=0, TDdn=0, curve='U1', scale=2, freq=60, CTR_up=1, CTR_dn=1, tfixed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Radial Time Dial Coordination Function</p>
<p>Function to evaluate the Time-Dial (TD) setting in radial schemes
where the Coordinating Time Interval (CTI) and the up/downstream
pickup settings are known along with the TD setting for the
downstream protection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Measured fault current in Amps, typically set using the
maximum fault current available.</dd>
<dt><strong><code>CTI</code></strong> :&ensp;<code>
float</code></dt>
<dd>Coordinating Time Interval in cycles.</dd>
<dt><strong><code>Ipu_up</code></strong> :&ensp;<code>
float</code></dt>
<dd>Pickup setting for upstream protection,
specified in amps</dd>
<dt><strong><code>Ipu_dn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Pickup setting for downstream protection,
specified in amps, default=0</dd>
<dt><strong><code>TDdn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Time-Dial setting for downstream protection,
specified in seconds, default=0</dd>
<dt><strong><code>curve</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>Name of specified TOC curve, may be entry from set:
{U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Scaling value used to evaluate a practical TD
setting, default=2</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System operating frequency, default=60</dd>
<dt><strong><code>CTR_up</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio for upstream relay.
default=1</dd>
<dt><strong><code>CTR_dn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio for downstream relay.
default=1</dd>
<dt><strong><code>tfixed</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Used to specify a fixed time delay for coordinated
protection elements, primarily used for coordinating
TOC elements (51) with OC elements (50) with a fixed
tripping time. Overrides downstream TOC arguments
including <em>Ipu_dn</em> and <em>TDdn</em>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>TD</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated Time-Dial setting according to radial
scheme logical analysis.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tdradial(I,CTI,Ipu_up,Ipu_dn=0,TDdn=0,curve=&#34;U1&#34;,scale=2,freq=60,
                  CTR_up=1,CTR_dn=1,tfixed=None):
    &#34;&#34;&#34;
    Radial Time Dial Coordination Function
    
    Function to evaluate the Time-Dial (TD) setting in radial schemes
    where the Coordinating Time Interval (CTI) and the up/downstream
    pickup settings are known along with the TD setting for the
    downstream protection.
    
    Parameters
    ----------
    I:          float
                Measured fault current in Amps, typically set using the
                maximum fault current available.
    CTI:        float
                Coordinating Time Interval in cycles.
    Ipu_up:     float
                Pickup setting for upstream protection,
                specified in amps
    Ipu_dn:     float, optional
                Pickup setting for downstream protection,
                specified in amps, default=0
    TDdn:       float, optional
                Time-Dial setting for downstream protection,
                specified in seconds, default=0
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    scale:      int, optional
                Scaling value used to evaluate a practical TD
                setting, default=2
    freq:       float, optional
                System operating frequency, default=60
    CTR_up:     float, optional
                Current Transformer Ratio for upstream relay.
                default=1
    CTR_dn:     float, optional
                Current Transformer Ratio for downstream relay.
                default=1
    tfixed:     float, optional
                Used to specify a fixed time delay for coordinated
                protection elements, primarily used for coordinating
                TOC elements (51) with OC elements (50) with a fixed
                tripping time. Overrides downstream TOC arguments
                including *Ipu_dn* and *TDdn*.
    
    Returns
    -------
    TD:         float
                Calculated Time-Dial setting according to radial
                scheme logical analysis.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    const = {   &#34;U1&#34; : {&#34;A&#34;: 0.0104, &#34;B&#34;: 0.2256, &#34;P&#34;: 0.02},
                &#34;U2&#34; : {&#34;A&#34;: 5.95, &#34;B&#34;: 0.180, &#34;P&#34;: 2.00},
                &#34;U3&#34; : {&#34;A&#34;: 3.88, &#34;B&#34;: 0.0963, &#34;P&#34;: 2.00},
                &#34;U4&#34; : {&#34;A&#34;: 5.67, &#34;B&#34;: 0.352, &#34;P&#34;: 2.00},
                &#34;U5&#34; : {&#34;A&#34;: 0.00342, &#34;B&#34;: 0.00262, &#34;P&#34;: 0.02},
                &#34;C1&#34; : {&#34;A&#34;: 0.14, &#34;B&#34;:0, &#34;P&#34;: 0.02},
                &#34;C2&#34; : {&#34;A&#34;: 13.5, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C3&#34; : {&#34;A&#34;: 80.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C4&#34; : {&#34;A&#34;: 120.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C5&#34; : {&#34;A&#34;: 0.05, &#34;B&#34;:0, &#34;P&#34;: 0.04}}
    # Load Constants
    A = const[curve][&#34;A&#34;]
    B = const[curve][&#34;B&#34;]
    P = const[curve][&#34;P&#34;]
    if tfixed == None:
        # Evaluate in seconds from cycles
        CTI = CTI/freq
        # Evaluate M
        M = I / (CTR_dn * Ipu_dn)
        # Evaluate Trip Time
        tpu_desired = TDdn * (A/(M**P-1)+B) + CTI
    else:
        tpu_desired = tfixed + CTI
    # Re-Evaluate M
    M = I / (CTR_up * Ipu_up)
    # Calculate TD setting
    TD = tpu_desired / (A/(M**2-1)+B)
    # Scale and Round
    TD = _np.floor(TD*10**scale)/10**scale
    return(TD)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.thermaltime"><code class="name flex">
<span>def <span class="ident">thermaltime</span></span>(<span>In, Ibase, tbase)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Thermal Time Limit Calculator</p>
<p>Computes the maximum allowable time for a specified
current <code>In</code> given parameters for a maximum current
and time at some other level, (<code>Ibase</code>, <code>tbase</code>).</p>
<p>Uses the following formula:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>In</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current at which to calculate max time.</dd>
<dt><strong><code>Ibase</code></strong> :&ensp;<code>
float</code></dt>
<dd>Base current, at which maximum time
<code>tbase</code> is allowable.</dd>
<dt><strong><code>tbase</code></strong> :&ensp;<code>
float</code></dt>
<dd>Base time for which a maximum allowable
current <code>Ibase</code> is specified. Unitless.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tn</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time allowable for specified current,
<code>In</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thermaltime(In,Ibase,tbase):
    &#34;&#34;&#34;
    Simple Thermal Time Limit Calculator
    
    Computes the maximum allowable time for a specified
    current `In` given parameters for a maximum current
    and time at some other level, (`Ibase`, `tbase`).
    
    Uses the following formula:
    
    .. math:: t_n=\\frac{I_{base}^2*t_{base}}{I_n^2}
    
    Parameters
    ----------
    In:         float
                Current at which to calculate max time.
    Ibase:      float
                Base current, at which maximum time
                `tbase` is allowable.
    tbase:      float
                Base time for which a maximum allowable
                current `Ibase` is specified. Unitless.
    
    Returns
    -------
    tn:         float
                Time allowable for specified current,
                `In`.
    &#34;&#34;&#34;
    # Perform Calculation
    tn = (Ibase**2*tbase)/(In**2)
    return(tn)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.tocreset"><code class="name flex">
<span>def <span class="ident">tocreset</span></span>(<span>I, Ipickup, TD, curve='U1', CTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Time OverCurrent Reset Time Function</p>
<p>Function to calculate the time to reset for a TOC
(Time-OverCurrent, 51) element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Measured Current in Amps</dd>
<dt><strong><code>Ipickup</code></strong> :&ensp;<code>
float</code></dt>
<dd>Fault Current Pickup Setting (in Amps)</dd>
<dt><strong><code>TD</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time Dial Setting</dd>
<dt><strong><code>curve</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>Name of specified TOC curve, may be entry from set:
{U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time-to-Reset for characterized element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tocreset(I,Ipickup,TD,curve=&#34;U1&#34;,CTR=1):
    &#34;&#34;&#34;
    Time OverCurrent Reset Time Function
    
    Function to calculate the time to reset for a TOC
    (Time-OverCurrent, 51) element.
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    TD:         float
                Time Dial Setting
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    tr:         float
                Time-to-Reset for characterized element.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    C = {   &#34;U1&#34; : 1.08,&#34;U2&#34; : 5.95,&#34;U3&#34; : 3.88,
            &#34;U4&#34; : 5.67,&#34;U5&#34; : 0.323,&#34;C1&#34; : 13.5,
            &#34;C2&#34; : 47.3,&#34;C3&#34; : 80.0,&#34;C4&#34; : 120.0,
            &#34;C5&#34; : 4.85}
    # Evaluate M
    M = I / (CTR * Ipickup)
    # Evaluate Reset Time
    tr = TD * (C[curve]/(1-M**2))
    return(tr)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.toctriptime"><code class="name flex">
<span>def <span class="ident">toctriptime</span></span>(<span>I, Ipickup, TD, curve='U1', CTR=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Time OverCurrent Trip Time Function</p>
<p>Time-OverCurrent Trip Time Calculator, evaluates the time
to trip for a specific TOC (51) element given the curve
type, current characteristics and time-dial setting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Measured Current in Amps</dd>
<dt><strong><code>Ipickup</code></strong> :&ensp;<code>
float</code></dt>
<dd>Fault Current Pickup Setting (in Amps)</dd>
<dt><strong><code>TD</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time Dial Setting</dd>
<dt><strong><code>curve</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>Name of specified TOC curve, may be entry from set:
{U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1</dd>
<dt><strong><code>CTR</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Current Transformer Ratio, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tt</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time-to-Trip for characterized element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toctriptime(I,Ipickup,TD,curve=&#34;U1&#34;,CTR=1):
    &#34;&#34;&#34;
    Time OverCurrent Trip Time Function
    
    Time-OverCurrent Trip Time Calculator, evaluates the time
    to trip for a specific TOC (51) element given the curve
    type, current characteristics and time-dial setting.
    
    Parameters
    ----------
    I:          float
                Measured Current in Amps
    Ipickup:    float
                Fault Current Pickup Setting (in Amps)
    TD:         float
                Time Dial Setting
    curve:      string, optional
                Name of specified TOC curve, may be entry from set:
                {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
    CTR:        float, optional
                Current Transformer Ratio, default=1
    
    Returns
    -------
    tt:         float
                Time-to-Trip for characterized element.
    &#34;&#34;&#34;
    # Condition Inputs
    curve = curve.upper()
    # Define Dictionary of Constants
    const = {   &#34;U1&#34; : {&#34;A&#34;: 0.0104, &#34;B&#34;: 0.2256, &#34;P&#34;: 0.02},
                &#34;U2&#34; : {&#34;A&#34;: 5.95, &#34;B&#34;: 0.180, &#34;P&#34;: 2.00},
                &#34;U3&#34; : {&#34;A&#34;: 3.88, &#34;B&#34;: 0.0963, &#34;P&#34;: 2.00},
                &#34;U4&#34; : {&#34;A&#34;: 5.67, &#34;B&#34;: 0.352, &#34;P&#34;: 2.00},
                &#34;U5&#34; : {&#34;A&#34;: 0.00342, &#34;B&#34;: 0.00262, &#34;P&#34;: 0.02},
                &#34;C1&#34; : {&#34;A&#34;: 0.14, &#34;B&#34;:0, &#34;P&#34;: 0.02},
                &#34;C2&#34; : {&#34;A&#34;: 13.5, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C3&#34; : {&#34;A&#34;: 80.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C4&#34; : {&#34;A&#34;: 120.0, &#34;B&#34;:0, &#34;P&#34;: 2.00},
                &#34;C5&#34; : {&#34;A&#34;: 0.05, &#34;B&#34;:0, &#34;P&#34;: 0.04}}
    # Load Constants
    A = const[curve][&#34;A&#34;]
    B = const[curve][&#34;B&#34;]
    P = const[curve][&#34;P&#34;]
    # Evaluate M
    M = I / (CTR * Ipickup)
    # Evaluate Trip Time
    tt = TD * (A/(M**P-1)+B)
    return(tt)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.transmismatch"><code class="name flex">
<span>def <span class="ident">transmismatch</span></span>(<span>I1, I2, tap1, tap2)</span>
</code></dt>
<dd>
<div class="desc"><p>Transformer TAP Mismatch Function</p>
<p>Function to evaluate the transformer ratio mismatch
for protection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I1</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Current (in amps) on transformer primary side.</dd>
<dt><strong><code>I2</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Current (in amps) on transformer secondary.</dd>
<dt><strong><code>tap1</code></strong> :&ensp;<code>
float</code></dt>
<dd>Relay TAP setting on the primary side.</dd>
<dt><strong><code>tap2</code></strong> :&ensp;<code>
float</code></dt>
<dd>Relay TAP setting on the secondary side.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mismatch</code></strong> :&ensp;<code>
float</code></dt>
<dd>Transformer CT mismatch value associated with
relay.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transmismatch(I1,I2,tap1,tap2):
    &#34;&#34;&#34;
    Transformer TAP Mismatch Function
    
    Function to evaluate the transformer ratio mismatch
    for protection.
    
    Parameters
    ----------
    I1:         complex
                Current (in amps) on transformer primary side.
    I2:         complex
                Current (in amps) on transformer secondary.
    tap1:       float
                Relay TAP setting on the primary side.
    tap2:       float
                Relay TAP setting on the secondary side.
    
    Returns
    -------
    mismatch:   float
                Transformer CT mismatch value associated with
                relay.
    &#34;&#34;&#34;
    # Evaluate MR
    MR = min( abs(I1/I2), abs(tap1/tap2) )
    # Calculate Mismatch
    mismatch = (abs(I1/I2) - abs(tap1/tap2))*100/MR
    return(mismatch)</code></pre>
</details>
</dd>
<dt id="electricpy.fault.trvresistor"><code class="name flex">
<span>def <span class="ident">trvresistor</span></span>(<span>C, L, reduction, Rd0=500, wd0=260000.0, tpk0=1e-05)</span>
</code></dt>
<dd>
<div class="desc"><p>Transient Recovery Voltage (TRV) Reduction Resistor Function</p>
<p>Function to find the resistor value that
will reduce the TRV by a specified
percentage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance Value in Farads.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance in Henries.</dd>
<dt><strong><code>reduction</code></strong> :&ensp;<code> float</code></dt>
<dd>The percentage that the TRV
should be reduced by.</dd>
<dt><strong><code>Rd0</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Damping Resistor Evaluation Starting Point
default=500</dd>
<dt><strong><code>wd0</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Omega-d evaluation starting point, default=260*k</dd>
<dt><strong><code>tpk0</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Time of peak voltage evaluation starting point,
default=10*u</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Rd</code></strong> :&ensp;<code>
float</code></dt>
<dd>Damping resistor value, in ohms.</dd>
<dt><strong><code>wd</code></strong> :&ensp;<code>
float</code></dt>
<dd>Omega-d</dd>
<dt><strong><code>tpk</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time of peak voltage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trvresistor(C,L,reduction,Rd0=500,wd0=260e3,tpk0=10e-6):
    &#34;&#34;&#34;
    Transient Recovery Voltage (TRV) Reduction Resistor Function
    
    Function to find the resistor value that
    will reduce the TRV by a specified
    percentage.
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    reduction:  float
                The percentage that the TRV
                should be reduced by.
    Rd0:        float, optional
                Damping Resistor Evaluation Starting Point
                default=500
    wd0:        float, optional
                Omega-d evaluation starting point, default=260*k
    tpk0:       float, optional
                Time of peak voltage evaluation starting point,
                default=10*u
    
    Returns
    -------
    Rd:         float
                Damping resistor value, in ohms.
    wd:         float
                Omega-d
    tpk:        float
                Time of peak voltage.
    &#34;&#34;&#34;
    # Evaluate omega-n
    wn = 1/_np.sqrt(L*C)
    # Generate Constant Factor
    fctr = (1-reduction)*2 - 1
    # Define Function Set
    def equations(data):
        Rd, wd, tpk = data
        X = _np.sqrt(wn**2-(1/(2*Rd*C))**2) - wd
        Y = _np.exp(-tpk/(2*Rd*C))-fctr
        Z = wd*tpk - _np.pi
        return(X,Y,Z)
    Rd, wd, tpk = _fsolve(equations, (Rd0,wd0,tpk0))
    return(Rd, wd, tpk)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#electricpyfaultpy">electricpy.fault.py</a></li>
<li><a href="#included-functions">Included Functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="electricpy" href="index.html">electricpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="electricpy.fault.busvolt" href="#electricpy.fault.busvolt">busvolt</a></code></li>
<li><code><a title="electricpy.fault.correctedcurrents" href="#electricpy.fault.correctedcurrents">correctedcurrents</a></code></li>
<li><code><a title="electricpy.fault.ct_cclass" href="#electricpy.fault.ct_cclass">ct_cclass</a></code></li>
<li><code><a title="electricpy.fault.ct_satratburden" href="#electricpy.fault.ct_satratburden">ct_satratburden</a></code></li>
<li><code><a title="electricpy.fault.ct_saturation" href="#electricpy.fault.ct_saturation">ct_saturation</a></code></li>
<li><code><a title="electricpy.fault.ct_timetosat" href="#electricpy.fault.ct_timetosat">ct_timetosat</a></code></li>
<li><code><a title="electricpy.fault.ct_vpeak" href="#electricpy.fault.ct_vpeak">ct_vpeak</a></code></li>
<li><code><a title="electricpy.fault.distmeasz" href="#electricpy.fault.distmeasz">distmeasz</a></code></li>
<li><code><a title="electricpy.fault.faultratio" href="#electricpy.fault.faultratio">faultratio</a></code></li>
<li><code><a title="electricpy.fault.genlossfield" href="#electricpy.fault.genlossfield">genlossfield</a></code></li>
<li><code><a title="electricpy.fault.highzmini" href="#electricpy.fault.highzmini">highzmini</a></code></li>
<li><code><a title="electricpy.fault.highzvpickup" href="#electricpy.fault.highzvpickup">highzvpickup</a></code></li>
<li><code><a title="electricpy.fault.indmacheigenvalues" href="#electricpy.fault.indmacheigenvalues">indmacheigenvalues</a></code></li>
<li><code><a title="electricpy.fault.indmachphs3sc" href="#electricpy.fault.indmachphs3sc">indmachphs3sc</a></code></li>
<li><code><a title="electricpy.fault.indmachphs3torq" href="#electricpy.fault.indmachphs3torq">indmachphs3torq</a></code></li>
<li><code><a title="electricpy.fault.instoc" href="#electricpy.fault.instoc">instoc</a></code></li>
<li><code><a title="electricpy.fault.iopirt" href="#electricpy.fault.iopirt">iopirt</a></code></li>
<li><code><a title="electricpy.fault.phs1g" href="#electricpy.fault.phs1g">phs1g</a></code></li>
<li><code><a title="electricpy.fault.phs1mvasc" href="#electricpy.fault.phs1mvasc">phs1mvasc</a></code></li>
<li><code><a title="electricpy.fault.phs2" href="#electricpy.fault.phs2">phs2</a></code></li>
<li><code><a title="electricpy.fault.phs2g" href="#electricpy.fault.phs2g">phs2g</a></code></li>
<li><code><a title="electricpy.fault.phs3" href="#electricpy.fault.phs3">phs3</a></code></li>
<li><code><a title="electricpy.fault.phs3mvasc" href="#electricpy.fault.phs3mvasc">phs3mvasc</a></code></li>
<li><code><a title="electricpy.fault.pickup" href="#electricpy.fault.pickup">pickup</a></code></li>
<li><code><a title="electricpy.fault.pktransrecvolt" href="#electricpy.fault.pktransrecvolt">pktransrecvolt</a></code></li>
<li><code><a title="electricpy.fault.poleopen1" href="#electricpy.fault.poleopen1">poleopen1</a></code></li>
<li><code><a title="electricpy.fault.poleopen2" href="#electricpy.fault.poleopen2">poleopen2</a></code></li>
<li><code><a title="electricpy.fault.protectiontap" href="#electricpy.fault.protectiontap">protectiontap</a></code></li>
<li><code><a title="electricpy.fault.residcomp" href="#electricpy.fault.residcomp">residcomp</a></code></li>
<li><code><a title="electricpy.fault.scMVA" href="#electricpy.fault.scMVA">scMVA</a></code></li>
<li><code><a title="electricpy.fault.symrmsfaultcur" href="#electricpy.fault.symrmsfaultcur">symrmsfaultcur</a></code></li>
<li><code><a title="electricpy.fault.synmach_Iasym" href="#electricpy.fault.synmach_Iasym">synmach_Iasym</a></code></li>
<li><code><a title="electricpy.fault.synmach_Isym" href="#electricpy.fault.synmach_Isym">synmach_Isym</a></code></li>
<li><code><a title="electricpy.fault.synmach_ifault" href="#electricpy.fault.synmach_ifault">synmach_ifault</a></code></li>
<li><code><a title="electricpy.fault.tdradial" href="#electricpy.fault.tdradial">tdradial</a></code></li>
<li><code><a title="electricpy.fault.thermaltime" href="#electricpy.fault.thermaltime">thermaltime</a></code></li>
<li><code><a title="electricpy.fault.tocreset" href="#electricpy.fault.tocreset">tocreset</a></code></li>
<li><code><a title="electricpy.fault.toctriptime" href="#electricpy.fault.toctriptime">toctriptime</a></code></li>
<li><code><a title="electricpy.fault.transmismatch" href="#electricpy.fault.transmismatch">transmismatch</a></code></li>
<li><code><a title="electricpy.fault.trvresistor" href="#electricpy.fault.trvresistor">trvresistor</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>